/*
  Copyright 2016 John LaGrone

  This file is part of RBCPACK.

  The Yee CRBC Library is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published by 
  the Free Software Foundation, either version 3 of the License, or (at your 
  option) any later version.

  The RBCPACK Library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of 
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License
  along with the RBCPACK Library.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
   This file declares a few solution routines for Maxwell's equations

*/ 

#ifndef MAXWELL_SOLUTIONS_H_
#define MAXWELL_SOLUTIONS_H_

// This has the declarations of the 'sqrt' and 'fabs' functions
#include <cmath>

namespace maxwell_solutions {

/// Enumeration to set valid methods for calculating derivatives
enum deriv_meth {
        EXACT = 0,   /**< Calculate exactly                                */
        FD_YEE,      /**< Calculate using finite differences on a Yee grid */
};

/// \class MW_FreeSpace
///
/// Computes the exact solution to the 3D Maxwell Equations in free space
///
///   The solution is generated by defining a vector field W
///   where the components w1, w2, and w3 are given to be
///
///   w1 = w2 = w3 = exp(-gamma (t + tau - r)^2) / r,
///
///   where r = sqrt((x-xsrc)^2 + (y-ysrc)^2 + (z-zsrc)^2).
///
///   This corresponds to a point source solution of the wave
///   equation with a time amplitude of the form exp(-gamma(t + alpha)^2)
///   located at (xsrc, ysrc, zsrc). This assumes that the speed
///   c = 1 / sqrt(eps*mu).
///
/// Some notes on use:
///
/// When using this to generate initial conditions for a simulation, some 
/// though needs to be given to the parameters tau and gamma. Essentially, 
/// the source needs to have been "turned on" and "off" before the simulation
/// starts. To make this precise, we need to satisfy
///
///      c*tau - alpha / sqrt(gamma) > 0
///
/// where alpha is a tolerance parameter (tol ~ exp(-alpha^2)). Experimentally
/// alpha = 5 seems to work in most cases, which corresponds to the source 
/// contribution being 0 to 13 digits at the source location and t = 0. Choosing 
/// alpha = 6, should give ~16 digits
///
/// Similarly, if the initial conditions are to appear to be compactly supported
/// in some domain. The farthest the wave front can be nonzero relative to the 
/// source location is
///
///   r = c*tau + alpha / sqrt(gamma).
///
/// Finally, a division by zero (which is not checked) is potentially possible
/// if the solution is evaluated at the source location.
class MW_FreeSpace
{

public:

  /// default constructor
  MW_FreeSpace() {};

  /// Constructor
  /// \param[in] gamma        roughly, 1/variance of the gaussian, should be >0
  /// \param[in] tau          time since the pulse was "turned on", should be >0
  /// \param[in] eps          epsilon
  /// \param[in] mu           mu
  /// \param[in] src_loc      x,y,z coordinates of the source
  MW_FreeSpace(const double &gamma, 
                   const double &tau, 
                   const double &eps,
                   const double &mu,
                   const double src_loc[3]);

  // Destructor
  virtual ~MW_FreeSpace() {};

  /// Method to set how the derivatives are calculated, defaults to exact if not
  /// set. This is used to calculate the curls. In the Yee scheme it is 
  /// beneficial to compute curls using the finite difference operators because
  /// this will result in a solution that is numerically divergence free.
  /// \param[in] dm  derivative method to use
  void set_derivative_method(const deriv_meth &dm) {this->dm = dm;};

  /// Set the grid spacing used for finite differencing. If this is not set
  /// derivatives will be calculated exactly regardless of method chosen
  /// \param[in] h  grid spacing
  void set_grid_spacing(const double h[3]) 
       {for (int i = 0; i<3; ++i) this->h[i] = h[i]; h_set = true;};

  // These functions are virtual because it may be advantageous to use this
  // class as a base for a more exotic solution routine. The intial thought
  // was that we could use a different implementation of these functions to 
  // generate a solution using the method of images to get the solution in, e.g.
  // a wave guide. For Maxwell's equations, this process is slightly more
  // subtle because the appropriate boundary conditions vary by component.
  
  /// routine to get the solution for all components, note this is cheaper
  /// if all components are needed at the same point
  /// \param[in] x     location to compute solution at
  /// \param[in] t     time to compute solution at
  /// \param[out] sol  Solution, ordered Ex, Ey, Ez, Hx, Hy, Hz
  virtual void get_solution(const double x[3], const double &t, double sol[6]) const;

  /// routine to get the solution for the Ex component
  /// \param[in] x     location to compute solution at
  /// \param[in] t     time to compute solution at
  /// \return          solution at Ex
  virtual double get_Ex_solution(const double x[3], const double &t) const;

  /// routine to get the solution for the Ey component
  /// \param[in] x     location to compute solution at
  /// \param[in] t     time to compute solution at
  /// \return          solution at Ey
  virtual double get_Ey_solution(const double x[3], const double &t) const;

  /// routine to get the solution for the Ez component
  /// \param[in] x     location to compute solution at
  /// \param[in] t     time to compute solution at
  /// \return          solution at Ez
  virtual double get_Ez_solution(const double x[3], const double &t) const;

  /// routine to get the solution for the Hx component
  /// \param[in] x     location to compute solution at
  /// \param[in] t     time to compute solution at
  /// \return          solution at Hx
  virtual double get_Hx_solution(const double x[3], const double &t) const;

  /// routine to get the solution for the Hy component
  /// \param[in] x     location to compute solution at
  /// \param[in] t     time to compute solution at
  /// \return          solution at Hy
  virtual double get_Hy_solution(const double x[3], const double &t) const;

  /// routine to get the solution for the Hz component
  /// \param[in] x     location to compute solution at
  /// \param[in] t     time to compute solution at
  /// \return          solution at Hz
  virtual double get_Hz_solution(const double x[3], const double &t) const;

private:

  /// routine to calculate the solution for all components, note this is cheaper
  /// if all components are needed at the same point
  /// \param[in] x     location to compute solution at
  /// \param[in] t     time to compute solution at
  /// \param[out] sol  Solution, ordered Ex, Ey, Ez, Hx, Hy, Hz
  void compute_solution(const double x[3], const double &t, double sol[6]) const;

  /// routine to calculate the solution for the Ex component
  /// \param[in] x     location to compute solution at
  /// \param[in] t     time to compute solution at
  /// \return          solution at Ex
  double compute_Ex_solution(const double x[3], const double &t) const;

  /// routine to calculate the solution for the Ey component
  /// \param[in] x     location to compute solution at
  /// \param[in] t     time to compute solution at
  /// \return          solution at Ey
  double compute_Ey_solution(const double x[3], const double &t) const;

  /// routine to calculate the solution for the Ez component
  /// \param[in] x     location to compute solution at
  /// \param[in] t     time to compute solution at
  /// \return          solution at Ez
  double compute_Ez_solution(const double x[3], const double &t) const;

  /// routine to calculate the solution for the Hx component
  /// \param[in] x     location to compute solution at
  /// \param[in] t     time to compute solution at
  /// \return          solution at Hx
  double compute_Hx_solution(const double x[3], const double &t) const;

  /// routine to calculate the solution for the Hy component
  /// \param[in] x     location to compute solution at
  /// \param[in] t     time to compute solution at
  /// \return          solution at Hy
  double compute_Hy_solution(const double x[3], const double &t) const;

  /// routine to calculate the solution for the Hz component
  /// \param[in] x     location to compute solution at
  /// \param[in] t     time to compute solution at
  /// \return          solution at Hz
  double compute_Hz_solution(const double x[3], const double &t) const;

  double gamma, tau, eps, mu, c, src_loc[3], h[3];
  deriv_meth dm;
  bool h_set;
    
}; // end class MW_FreeSpace

} // end namespace maxwell_solutions

#endif // MAXWELL_SOLUTIONS_H_
