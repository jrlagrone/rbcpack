<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3-D FDTD code with CRBC/DAB Boundary Conditions using MPI &#8212; RBCPack  documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Transverse-Electromagnetic Example Interfacing the DAB/CRBC library with an External Yee Scheme" href="quick_start/te.html" />
    <link rel="prev" title="Wave Equation code with CRBC/DAB Boundary Conditions" href="wave_eq_example_in_Cpp.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          rbcpack</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Components <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Yee/FDTD</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#downloads-and-respository">Downloads and Respository</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#documentation">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/index.html">Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Utilities/index.html#optimal-cosines">Optimal Cosines</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contrib.html">rbcpack Contributors</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Current Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">3-D FDTD code with CRBC/DAB Boundary Conditions using MPI</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#what-this-program-does">What this program does</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-declaration-and-code-structure">Class Declaration and Code Structure</a><ul>
<li><a class="reference internal" href="#include-files">Include files</a></li>
<li><a class="reference internal" href="#yee-updater-class-declaration">yee_updater class declaration</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-definitions">Class Definitions</a><ul>
<li><a class="reference internal" href="#includes">Includes</a></li>
<li><a class="reference internal" href="#constructor">Constructor</a></li>
<li><a class="reference internal" href="#routine-to-run-the-simulation">Routine to run the Simulation</a></li>
<li><a class="reference internal" href="#function-to-free-communicators">Function to Free Communicators</a></li>
<li><a class="reference internal" href="#function-to-print-approximate-memory-usage">Function to Print Approximate Memory Usage</a></li>
<li><a class="reference internal" href="#function-to-print-timing-data">Function to Print Timing Data</a></li>
<li><a class="reference internal" href="#routine-to-calculate-parameters">Routine to Calculate Parameters</a></li>
<li><a class="reference internal" href="#function-to-create-a-mpi-communicator">Function to Create a MPI Communicator</a></li>
<li><a class="reference internal" href="#function-to-initialize-solutions">Function to Initialize Solutions</a></li>
<li><a class="reference internal" href="#function-to-allocate-memory">Function to Allocate Memory</a></li>
<li><a class="reference internal" href="#function-to-initilize-the-dab-layer">Function to Initilize the DAB Layer</a></li>
<li><a class="reference internal" href="#function-to-update-e-fields">Function to Update E-Fields</a></li>
<li><a class="reference internal" href="#function-to-compute-interior-h-field-updates">Function to Compute Interior H-Field Updates</a></li>
<li><a class="reference internal" href="#routine-to-update-boundary-h-fields">Routine to Update Boundary H-Fields</a></li>
<li><a class="reference internal" href="#function-to-update-the-dab-values">Function to Update the DAB Values</a></li>
<li><a class="reference internal" href="#function-to-copy-updated-dab-values">Function to Copy Updated DAB Values</a></li>
<li><a class="reference internal" href="#functions-to-copy-to-and-from-dab-updaters">Functions to Copy To and From DAB Updaters</a></li>
<li><a class="reference internal" href="#function-to-identify-how-to-send-dab-auxiliary-variables">Function to Identify How to send DAB Auxiliary Variables</a></li>
<li><a class="reference internal" href="#function-to-send-dab-values">Function to send DAB Values</a></li>
<li><a class="reference internal" href="#function-to-receive-dab-values">Function to Receive DAB Values</a></li>
<li><a class="reference internal" href="#function-to-send-e-field-values">Function to Send E-Field Values</a></li>
<li><a class="reference internal" href="#function-to-receive-e-field-values">Function to Receive E field Values</a></li>
<li><a class="reference internal" href="#function-to-load-intitial-values">Function to Load Intitial Values</a></li>
<li><a class="reference internal" href="#function-to-calculate-the-norm">Function to Calculate the Norm</a></li>
<li><a class="reference internal" href="#function-to-calculate-error">Function to Calculate Error</a></li>
</ul>
</li>
<li><a class="reference internal" href="#example-driver">Example Driver</a></li>
<li><a class="reference internal" href="#compiling">Compiling</a></li>
<li><a class="reference internal" href="#sample-output">Sample Output</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="wave_eq_example_in_Cpp.html" title="Previous Chapter: Wave Equation code with CRBC/DAB Boundary Conditions"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Wave Equation...</span>
    </a>
  </li>
  <li>
    <a href="quick_start/te.html" title="Next Chapter: Transverse-Electromagnetic Example Interfacing the DAB/CRBC library with an External Yee Scheme"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Transverse-El... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary">  <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Yee/FDTD</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#downloads-and-respository">Downloads and Respository</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#licensing">Licensing</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#documentation">Documentation</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html#user-guides">User Guides</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#known-issues">Known Issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#theory-results-and-publications">Theory, Results, and Publications</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/index.html">Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Utilities/index.html#optimal-cosines">Optimal Cosines</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contrib.html">rbcpack Contributors</a></li>
</ul>

<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <div class="section" id="d-fdtd-code-with-crbc-dab-boundary-conditions-using-mpi">
<h1>3-D FDTD code with CRBC/DAB Boundary Conditions using MPI<a class="headerlink" href="#d-fdtd-code-with-crbc-dab-boundary-conditions-using-mpi" title="Permalink to this headline">¶</a></h1>
<p>This tutorial explains the code contained primarily in the files
<a class="reference external" href="https://github.com/jrlagrone/rbcpack/blob/main/YeeCRBC/examples/yee_mpi/yee_mpi.cpp">yee_mpi.cpp</a>,
<a class="reference external" href="https://github.com/jrlagrone/rbcpack/blob/main/YeeCRBC/examples/yee_mpi/yee_mpi.hpp">yee_mpi.hpp</a>,
and <a class="reference external" href="https://github.com/jrlagrone/rbcpack/blob/main/YeeCRBC/examples/yee_mpi/yee_mpi_example.cpp">yee_mpi_example.cpp</a>.</p>
<div class="alert alert-dismissible alert-warning">
  <button type="button" class="close" data-dismiss="alert">&times;</button>
  <h4>Warning!</h4>
  <p>This code is meant to serve as an example of how the CRBC/DAB library
     might be used in conjunction with MPI. We are not officially supporting
     MPI at this time, but we will try to answer related questions if we are
     able.
  </p>
  <p>This code has also experienced unexplained deadlock/stalling issues in
     testing. We believe that this may have been caused by memory and network
     problems, but have not been able to verify this theory. If you experience
     issues or find a bug, please contact John LaGrone at "jlagrone at smu dot edu".

  </p>
</div><div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This code implements the finite difference time-domain solution of
Maxwell’s equations (curl formulation) over a 3-D Cartesian lattice.
The grid is terminated using Double Absorbing Boundaries (DAB).</p>
<p>Before beginning, it would be a good idea to understand the serial implementation
of the <a class="reference internal" href="3D_Yee_example_in_C.html"><span class="doc">3D Yee Scheme</span></a>. The
<a class="reference internal" href="wave_eq_example_in_Cpp.html"><span class="doc">C++ wave equation example</span></a> may also be helpful in
understanding how the C++ library interface works.</p>
<div class="section" id="what-this-program-does">
<h3>What this program does<a class="headerlink" href="#what-this-program-does" title="Permalink to this headline">¶</a></h3>
<p>At the global level, this program is meant to do exactly the same thing as the
serial example of the <a class="reference internal" href="3D_Yee_example_in_C.html"><span class="doc">3D Yee Scheme</span></a>, but here
we will divide the work among the available MPI processes.
We consider Maxwell’s equations in a homogeneous,
isotropic, dielectric material is given by</p>
<div class="math notranslate nohighlight">
\begin{align}
  \frac{\partial \mathbf{H}}{\partial t} &amp;= - \frac{1}{\mu}  \nabla \times \mathbf{E}, \\
  \frac{\partial \mathbf{E}}{\partial t}&amp;= \frac{1}{\varepsilon} \nabla \times \mathbf{H},
\end{align}</div><p>subject to the constraints</p>
<div class="math notranslate nohighlight">
\begin{align}
  \nabla \cdot \mathbf{E} &amp;= 0, \\
  \nabla \cdot \mathbf{H} &amp;= 0.
\end{align}</div><p id="discretization">To discretize these equations using Yee’s scheme on a rectangular
domain <span class="math notranslate nohighlight">\([x_L, x_R] \times [y_L, y_R] \times [z_L, z_R]\)</span> with mesh spacings
of <span class="math notranslate nohighlight">\(\Delta x\)</span>,  <span class="math notranslate nohighlight">\(\Delta y\)</span>, and  <span class="math notranslate nohighlight">\(\Delta z\)</span>, in the
<span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(z\)</span> directions, respectively, we define</p>
<div class="math notranslate nohighlight">
\begin{align}
  x_i &amp;= x_L + i\Delta x, \\
  y_j &amp;= y_L + j\Delta y, \\
  z_k &amp;= z_L + k\Delta z.
\end{align}</div><p>We choose a time step size, <span class="math notranslate nohighlight">\(\Delta t\)</span>, satisfying</p>
<div class="math notranslate nohighlight">
\begin{align}
  \Delta t \leq \frac{1}{c \sqrt{\frac{1}{(\Delta x)^2} + \frac{1}{(\Delta y)^2} + \frac{1}{(\Delta z)^2}}},
\end{align}</div><p>with the wave speed given by</p>
<div class="math notranslate nohighlight">
\begin{align}
  c = \frac{1}{\sqrt{\varepsilon \mu}}.
\end{align}</div><p>Letting</p>
<div class="math notranslate nohighlight">
\begin{align}
  t_n = n \Delta t,
\end{align}</div><p>the fields are approximated on the staggered space time grids:</p>
<div class="math notranslate nohighlight">
\begin{align}
  E_x^{i+\frac{1}{2},j,k,n+\frac{1}{2}} &amp; \sim E_x(x_{i+\frac{1}{2}},y_j,z_k,t_{n+\frac{1}{2}}), \\
  E_y^{i,j+\frac{1}{2},k,n+\frac{1}{2}} &amp; \sim E_y(x_i,y_{j+\frac{1}{2}},z_k,t_{n+\frac{1}{2}}), \\
  E_z^{i,j,k+\frac{1}{2},n+\frac{1}{2}} &amp; \sim E_z(x_i,y_j,z_{k+\frac{1}{2}},t_{n+\frac{1}{2}}), \\
  H_x^{i,j+\frac{1}{2},k+\frac{1}{2},n} &amp; \sim H_x(x_i,y_{j+\frac{1}{2}},z_{k+\frac{1}{2}},t_n), \\
  H_y^{i+\frac{1}{2},j,k+\frac{1}{2},n} &amp; \sim H_y(x_{i+\frac{1}{2}},y_j,z_{k+\frac{1}{2}},t_n), \\
  H_z^{i+\frac{1}{2},j+\frac{1}{2},k,n} &amp; \sim H_z(x_{i+\frac{1}{2}},y_{j+\frac{1}{2}},z_k,t_n),
\end{align}</div><p>where we require that the domain is terminated such that the tangential <strong>E</strong>
components and the normal <strong>H</strong> component are located on the boundaries. This
corresponds to having an integer number of Yee cells that match the
illustrated <a class="reference internal" href="#fig-yee-cell"><span class="std std-ref">Spatial configuration of a Yee cell.</span></a></p>
<div class="figure align-center" id="id3" style="width: 500px">
<span id="fig-yee-cell"></span><a class="reference internal image-reference" href="../_images/cell.png"><img alt="image of a Yee cell" src="../_images/cell.png" style="width: 450px;" /></a>
<p class="caption"><span class="caption-text">Spatial configuration of a Yee cell.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>Finally, the fields are evolved with</p>
<div class="math notranslate nohighlight">
\begin{align}
   H_x^{i,j+\frac{1}{2},k+\frac{1}{2},n+1}  = H_x^{i,j+\frac{1}{2},k+\frac{1}{2},n}
   &amp; +  \frac{\Delta t}{\mu \Delta z} \left(E_y^{i,j+\frac{1}{2},k+1,n+\frac{1}{2}}
   - E_y^{i,j+\frac{1}{2},k,n+\frac{1}{2}} \right) \\
   &amp; - \frac{\Delta t}{\mu \Delta y} \left(E_z^{i,j+1,k+\frac{1}{2},n+\frac{1}{2}}
   - E_z^{i,j,k+\frac{1}{2},n+\frac{1}{2}}    \right),  \nonumber \\
   % % % %
   H_y^{i+\frac{1}{2},j,k+\frac{1}{2},n+1}  = H_y^{i+\frac{1}{2},j,k+\frac{1}{2},n}
   &amp; + \frac{\Delta t}{\mu \Delta x} \left(E_z^{i+1,j,k+\frac{1}{2},n+\frac{1}{2}}
   - E_z^{i,j,k+\frac{1}{2},n+\frac{1}{2}} \right) \\
   &amp; -  \frac{\Delta t}{\mu \Delta z} \left(E_x^{i+\frac{1}{2},j,k+1,n+\frac{1}{2}}
   - E_x^{i+\frac{1}{2},j,k,n+\frac{1}{2}} \right), \nonumber \\
   % % % %
   H_z^{i+\frac{1}{2},j+\frac{1}{2},k,n+1}  = H_z^{i+\frac{1}{2},j+\frac{1}{2},k,n}
   &amp; +  \frac{\Delta t}{\mu \Delta y} \left(E_x^{i+\frac{1}{2},j+1,k,n+\frac{1}{2}}
   - E_x^{i+\frac{1}{2},j,k,n+\frac{1}{2}}\right)    \\
   &amp; -  \frac{\Delta t}{\mu \Delta x} \left(E_y^{i+1,j+\frac{1}{2},k,n+\frac{1}{2}}
   - E_y^{i,j+\frac{1}{2},k,n+\frac{1}{2}} \right), \nonumber \\
   % % % % %
   E_x^{i+\frac{1}{2},j,k,n+\frac{1}{2}}  = E_x^{i+\frac{1}{2},j,k,n-\frac{1}{2}}
   &amp; + \frac{\Delta t}{\varepsilon \Delta y} \left(H_z^{i+\frac{1}{2},j+\frac{1}{2},k,n}
   - H_z^{i+\frac{1}{2},j-\frac{1}{2},k,n} \right)  \\
   &amp; - \frac{\Delta t}{\varepsilon \Delta z}  \left(H_y^{i+\frac{1}{2},j,k+\frac{1}{2},n}
   - H_y^{i+\frac{1}{2},j,k-\frac{1}{2},n}\right),  \nonumber \\
   % % % % %
   E_y^{i,j+\frac{1}{2},k,n+\frac{1}{2}}  = E_y^{i,j+\frac{1}{2},k,n-\frac{1}{2}}
   &amp; + \frac{\Delta t}{\varepsilon \Delta z}  \left(H_x^{i,j+\frac{1}{2},k+\frac{1}{2},n}
   - H_x^{i,j+\frac{1}{2},k-\frac{1}{2},n}\right) \\
   &amp; - \frac{\Delta t}{\varepsilon \Delta x}  \left(H_z^{i+\frac{1}{2},j+\frac{1}{2},k,n}
   - H_z^{i-\frac{1}{2},j+\frac{1}{2},k,n} \right),  \nonumber \\
   % % % % %
   E_z^{i,j,k+\frac{1}{2},n+\frac{1}{2}}  = E_z^{i,j,k+\frac{1}{2},n-\frac{1}{2}}
   &amp; + \frac{\Delta t}{\varepsilon \Delta x}  \left(H_y^{i+\frac{1}{2},j,k+\frac{1}{2},n}
   - H_y^{i-\frac{1}{2},j,k+\frac{1}{2},n} \right)   \\
   &amp; - \frac{\Delta t}{\varepsilon \Delta y}  \left(H_x^{i,j+\frac{1}{2},k+\frac{1}{2},n}
   - H_y^{i,j-\frac{1}{2},k-\frac{1}{2},n} \right).  \nonumber
\end{align}</div><p>We will use initial conditions generated from a Gaussian point source.</p>
</div>
</div>
<div class="section" id="class-declaration-and-code-structure">
<h2>Class Declaration and Code Structure<a class="headerlink" href="#class-declaration-and-code-structure" title="Permalink to this headline">¶</a></h2>
<p>First we briefly describe the definition of the <cite>yee_updater</cite> class that is declared
in header file <a class="reference external" href="https://github.com/jrlagrone/rbcpack/blob/main/YeeCRBC/examples/yee_mpi/yee_mpi.hpp">yee_mpi.hpp</a>.</p>
<div class="section" id="include-files">
<h3>Include files<a class="headerlink" href="#include-files" title="Permalink to this headline">¶</a></h3>
<p>First we include the most generic C++ interface to the CRBC/DAB boundary
conditions</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;crbc_updates.hpp&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>We include the header file for an exact solution routine so we can generate initial
conditions and calculate errors</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Header file for exact solution routines</span>
<span class="cp">#include</span> <span class="cpf">&quot;solutions.hpp&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>Next we include the standard template library vectors and arrays to minimize the
amount of memory we have to directly manage</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// for std::vector</span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="c1">// for std::array</span>
<span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>Finally, we include the Message Passing Interface library</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// include MPI for parallel implementation</span>
<span class="cp">#include</span> <span class="cpf">&lt;mpi.h&gt;</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="section" id="yee-updater-class-declaration">
<h3>yee_updater class declaration<a class="headerlink" href="#yee-updater-class-declaration" title="Permalink to this headline">¶</a></h3>
<p>For simplicity, we declare a C++ class assuming that the number of processes will
be a perfect cube and the domain will also be a cube. The primary inputs will be
an MPI communicator, the number of processes to use, the width of the domain, the
grid spacing, simulation time, and DAB parameters. The remaining inputs are
primarily to modify the solution and output parameters.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">class</span> <span class="n">yee_updater</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>

  <span class="c1">/// constructor</span>
  <span class="c1">/// \param[in] comm      MPI communicator</span>
  <span class="c1">/// \param[in] nprocs    the number of processes to use in each direction</span>
  <span class="c1">/// \param[in] w         the approximate domain width (may be changed slighty due to discretization)</span>
  <span class="c1">/// \param[in] n         number of grid points</span>
  <span class="c1">/// \param[in] T         the total simulation time</span>
  <span class="c1">/// \param[in] CRBC_T    CRBC time parameter (usually CRBC_T = T)</span>
  <span class="c1">/// \param[in] CRBC_P    the number of CRBC recursions</span>
  <span class="c1">/// \param[in] io_t      approximately how often to generate output</span>
  <span class="c1">/// \param[in] skip      the stride to use when sampling errors</span>
  <span class="c1">/// \param[in] eps       permittivity</span>
  <span class="c1">/// \param[in] mu        permeability</span>
  <span class="c1">/// \param[in] gamma     roughty 1/variance of the Gaussian pulse used for ICs</span>
  <span class="c1">/// \param[in] tau       how far in the past the source pulse was turned on (&gt; 0)</span>
  <span class="c1">/// \param[in] dab_wt    weight factor for DAB in load balancing</span>
  <span class="n">yee_updater</span><span class="p">(</span><span class="n">MPI_Comm</span> <span class="n">comm</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">nprocs</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">CRBC_T</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">CRBC_P</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">io_t</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">skip</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">mu</span>  <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">gamma</span> <span class="o">=</span> <span class="mf">160.0</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">tau</span> <span class="o">=</span> <span class="mf">0.35</span><span class="p">,</span>
            <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">dab_wt</span> <span class="o">=</span> <span class="mi">3</span><span class="p">);</span>

  <span class="n">virtual</span> <span class="o">~</span><span class="n">yee_updater</span><span class="p">();</span>
</pre></div>
</div>
<p>Next we declare the remaining public functions. Notably, a function to run the
simulation and one to free any memeroy associated with the MPI communicators.
We also declare functions to print out some information about memory usage and
timing data.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">/// run the simulation</span>
<span class="kt">void</span> <span class="nf">run</span><span class="p">();</span>

<span class="c1">/// free the communicators created internally</span>
<span class="kt">void</span> <span class="nf">free_comms</span><span class="p">();</span>

<span class="c1">/// function to display the approximate memory usage in MB</span>
<span class="kt">void</span> <span class="nf">print_mem_use</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">/// function to display timing information</span>
<span class="kt">void</span> <span class="nf">print_timing_data</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>We declare most of the data structures we will use in the following. Here, we
have everything that was in the serial example and we additionally have more
arrays to store indexing and relational information for each of the MPI processes
as well as buffers for the send and receives. We use std::vectors here so we don’t
have to worry about freeing memory.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="nl">private</span><span class="p">:</span>

  <span class="c1">// storage for field values</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">E</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">H</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

  <span class="kt">double</span> <span class="n">Hcoef</span><span class="p">,</span> <span class="n">Ecoef</span><span class="p">;</span>

  <span class="c1">// storage for mpi messages. The lengths correspond to worst case situations</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">E_sbuf</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">E_rbuf</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">E_edge_sbuf</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">E_edge_rbuf</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">DAB_sbuf</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">DAB_rbuf</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">DAB_corner_sbuf</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">DAB_corner_rbuf</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>

  <span class="kt">double</span> <span class="n">eps</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">io_t</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">Etime</span><span class="p">,</span> <span class="n">Htime</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">tol</span><span class="p">,</span> <span class="n">CRBC_T</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">coord</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">domain_width</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nprocs</span><span class="p">,</span> <span class="n">nprocs_cubed</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">maxn</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ntsteps</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">skip</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">dab_wt</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">isBoundaryProc</span><span class="p">;</span>
  <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">Boundary</span> <span class="n">procBounds</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">my_id</span><span class="p">,</span> <span class="n">cart_rank</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">MPI_EDGE_DIR</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">send_dirs</span><span class="p">,</span> <span class="n">send_mpi_dirs</span><span class="p">,</span> <span class="n">send_sides</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">corner_mpi_dirs</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">send_corners</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">send_edges</span><span class="p">;</span>
  <span class="n">crbc</span><span class="o">::</span><span class="n">CrbcUpdates</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="n">MPI_Comm</span> <span class="n">grid_comm</span><span class="p">,</span> <span class="n">glob_comm</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MPI_Request</span><span class="o">&gt;</span> <span class="n">send_req</span><span class="p">,</span> <span class="n">recv_req</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MPI_Request</span><span class="o">&gt;</span> <span class="n">DAB_send_req</span><span class="p">,</span> <span class="n">DAB_recv_req</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">DAB_props</span><span class="p">,</span> <span class="n">rDAB_props</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">DAB_refl</span><span class="p">,</span> <span class="n">rDAB_refl</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">create_comm_t</span><span class="p">,</span>  <span class="n">alloc_mem_t</span><span class="p">,</span> <span class="n">init_dab_t</span><span class="p">,</span> <span class="n">step_E_t</span><span class="p">,</span> <span class="n">step_inner_H_t</span><span class="p">,</span> \
       <span class="n">step_outer_H_t</span><span class="p">,</span> <span class="n">step_DAB_t</span><span class="p">,</span> <span class="n">send_DAB_t</span><span class="p">,</span> <span class="n">recv_DAB_t</span><span class="p">,</span> <span class="n">send_E_t</span><span class="p">,</span> \
       <span class="n">recv_E_t</span><span class="p">,</span> <span class="n">sol_t</span><span class="p">,</span> <span class="n">load_init_conds_t</span><span class="p">,</span> <span class="n">calc_norm_t</span><span class="p">,</span> <span class="n">calc_err_t</span><span class="p">,</span> <span class="n">calc_params_t</span><span class="p">;</span>

  <span class="kt">double</span> <span class="n">dab_mem_use</span><span class="p">;</span>

  <span class="n">maxwell_solutions</span><span class="o">::</span><span class="n">MW_FreeSpace</span> <span class="n">sol_obj</span><span class="p">;</span>
</pre></div>
</div>
<p>The next set of functions are used to set up the problem. These functions will
try to load balance the problem (in a simple way), create the communicators,
load initial conditions, and set up the boundary updaters.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">/// function to calculate parameters and do some basic load balancing</span>
<span class="kt">void</span> <span class="nf">calc_params</span><span class="p">();</span>

<span class="c1">/// function to create the internal mpi comm. It also labels the boundaries.</span>
<span class="kt">void</span> <span class="nf">create_mpi_comm</span><span class="p">(</span><span class="n">MPI_Comm</span> <span class="n">comm</span><span class="p">);</span>

<span class="c1">/// function to set up the solution routines</span>
<span class="kt">void</span> <span class="nf">init_solutions</span><span class="p">();</span>

<span class="c1">/// load the initial conditions</span>
<span class="kt">void</span> <span class="nf">load_initial_conds</span><span class="p">();</span>

<span class="c1">/// function to allocate memory</span>
<span class="kt">void</span> <span class="nf">allocate_memory</span><span class="p">();</span>

<span class="c1">/// function that sets up the DAB boundary updaters</span>
<span class="kt">void</span> <span class="nf">init_DAB</span><span class="p">();</span>
</pre></div>
</div>
<p>The functions are essentially the same as the serial case and serve to update
the E and H fields. We split the H-field updates to be for interior and boundary
updates so we can do some updates while we wait for message passing to complete.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">/// evolve the E fields</span>
<span class="kt">void</span> <span class="nf">step_E</span><span class="p">();</span>

<span class="c1">/// evolve the interior H fields</span>
<span class="kt">void</span> <span class="nf">step_inner_H</span><span class="p">();</span>

<span class="c1">/// evolve the H fields on the process boundaries</span>
<span class="kt">void</span> <span class="nf">step_outer_H</span><span class="p">();</span>

<span class="c1">/// update the DAB layers</span>
<span class="kt">void</span> <span class="nf">step_DAB</span><span class="p">();</span>

<span class="c1">/// copy the DAB updates back into the interior</span>
<span class="kt">void</span> <span class="nf">copy_DAB</span><span class="p">();</span>
</pre></div>
</div>
<p>These functions are simply commonly used loops for copying data between the DAB
library and the interior of our domain.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">/// often used loop that copies data from the DAB to the interior</span>
<span class="kt">void</span> <span class="nf">get_dab_vals_loop</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span>
                       <span class="n">crbc</span><span class="o">::</span><span class="n">CrbcUpdates</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">updater</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">side</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">low</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">high</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">plow</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">phigh</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">isedge</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>

<span class="c1">/// often used loop that copies data from the interior to the DAB</span>
<span class="kt">void</span> <span class="nf">set_dab_vals_loop</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span>
                       <span class="n">crbc</span><span class="o">::</span><span class="n">CrbcUpdates</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">updater</span><span class="p">,</span>
                       <span class="kt">int</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">side</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">low</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">high</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">plow</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">phigh</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">isedge</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>The bulk of the new code is in the following functions which handle the sending
and receiving of the MPI messages for the boundary values and the field values.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">/// function to indentify the sides and edges that need to be sent to update</span>
<span class="c1">/// the DAB layer</span>
<span class="kt">void</span> <span class="nf">calc_DAB_send_params</span><span class="p">();</span>

<span class="c1">/// send DAB values between processes</span>
<span class="kt">void</span> <span class="nf">send_DAB</span><span class="p">();</span>

<span class="c1">/// recieve DAB values from neighboring processes</span>
<span class="kt">void</span> <span class="nf">recv_DAB</span><span class="p">();</span>

<span class="c1">/// send E field values to neighboring processes</span>
<span class="kt">void</span> <span class="nf">send_E</span><span class="p">();</span>

<span class="c1">/// recieve E field values form neighboring processes</span>
<span class="kt">void</span> <span class="nf">recv_E</span><span class="p">();</span>
</pre></div>
</div>
<p>Finally, we have functions to compute the norm and error of the solutions.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">/// calculate the norm at the current time</span>
<span class="kt">double</span> <span class="nf">calc_norm</span><span class="p">();</span>

<span class="c1">/// calculate the error at the current time</span>
<span class="kt">double</span> <span class="nf">calc_error</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="class-definitions">
<h2>Class Definitions<a class="headerlink" href="#class-definitions" title="Permalink to this headline">¶</a></h2>
<p>The definitions for the <cite>yee_updater</cite> class are implemented in the file <a class="reference external" href="https://github.com/jrlagrone/rbcpack/blob/main/YeeCRBC/examples/yee_mpi/yee_mpi.cpp">yee_mpi.cpp</a>.</p>
<div class="section" id="includes">
<h3>Includes<a class="headerlink" href="#includes" title="Permalink to this headline">¶</a></h3>
<p>We begin by including the header file containing the class declarations:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;yee_mpi.hpp&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>Next we include the routines needed to produce output and calculate the error and
norms</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Needed for C++ output</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="c1">// This has the declarations of the &#39;sqrt&#39; and &#39;abs&#39; functions</span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>

<span class="c1">// We use this for std::accumulate</span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>Finally, we optionally include OpenMP to allow for threading</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// optional OpenMP</span>
<span class="cp">#if USE_OPENMP</span>
  <span class="cp">#include</span> <span class="cpf">&lt;omp.h&gt;</span><span class="cp"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>
<div class="section" id="constructor">
<h3>Constructor<a class="headerlink" href="#constructor" title="Permalink to this headline">¶</a></h3>
<p>The primary function of the constructor is to set up all of the problem parameters.
It expects to receive the MPI communicator to use, the number of process to use
in each direction (<cite>nprocs</cite> is the side length, not the total number), the width
of the domain, the number of grid points, and the simulation time. It additionally
takes the DAB/CRBC time parameter (usually this should be the same as the simulation
time) and the number of recursions to use. The remaining parameters are optional and set the output time and sampling frequency and the solution parameters. There is also a parameter to adjust how to scale the
work in the DAB layers for load balancing purposes (in experiements choosing this
to be 3-6 seems to work well in most cases).</p>
<p>We copy these inputs and set all the timer variables to 0. Note that the majority
of the MPI barriers in this section of code are unnecessary and are only here
to try to help isolate potential problems in the code.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">yee_updater</span><span class="o">::</span><span class="n">yee_updater</span><span class="p">(</span><span class="n">MPI_Comm</span> <span class="n">comm</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">nprocs</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">w</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">CRBC_T</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">CRBC_P</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">io_t</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">skip</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">eps</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">mu</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">gamma</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">tau</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">dab_wt</span><span class="p">)</span>
<span class="p">{</span>

  <span class="c1">// save inputs</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">CRBC_T</span> <span class="o">=</span> <span class="n">CRBC_T</span><span class="p">;</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">CRBC_P</span> <span class="o">=</span> <span class="n">CRBC_P</span><span class="p">;</span>
  <span class="n">domain_width</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">nprocs</span> <span class="o">=</span> <span class="n">nprocs</span><span class="p">;</span>
  <span class="n">n_global</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">io_t</span> <span class="o">=</span> <span class="n">io_t</span><span class="p">;</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">skip</span> <span class="o">=</span> <span class="n">skip</span><span class="p">;</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span><span class="p">;</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span><span class="p">;</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span><span class="p">;</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">tau</span> <span class="o">=</span> <span class="n">tau</span><span class="p">;</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">dab_wt</span> <span class="o">=</span> <span class="n">dab_wt</span><span class="p">;</span>

  <span class="c1">// compute the wave speed;</span>
  <span class="n">c</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">eps</span><span class="o">*</span><span class="n">mu</span><span class="p">);</span>

  <span class="c1">// make a copy of the communicator</span>
  <span class="n">MPI_Comm_dup</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">glob_comm</span><span class="p">);</span>

  <span class="c1">// initialize timers to 0</span>
  <span class="n">calc_params_t</span> <span class="o">=</span> <span class="n">create_comm_t</span> <span class="o">=</span> <span class="n">alloc_mem_t</span> <span class="o">=</span> <span class="n">init_dab_t</span> <span class="o">=</span> <span class="n">step_E_t</span> <span class="o">=</span> \
                <span class="n">step_inner_H_t</span> <span class="o">=</span> <span class="n">step_outer_H_t</span> <span class="o">=</span> <span class="n">step_DAB_t</span> <span class="o">=</span>  <span class="n">send_DAB_t</span> <span class="o">=</span> \
                <span class="n">recv_DAB_t</span> <span class="o">=</span> <span class="n">send_E_t</span> <span class="o">=</span> <span class="n">recv_E_t</span> <span class="o">=</span> <span class="n">sol_t</span> <span class="o">=</span> <span class="n">load_init_conds_t</span> <span class="o">=</span> \
                <span class="n">calc_norm_t</span> <span class="o">=</span> <span class="n">calc_err_t</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
</pre></div>
</div>
<p>Then, we set up a cartesian communicator and calculate the parameters for the
simulation and load balancing. The functions <a class="reference internal" href="#sec-create-mpi-comm"><span class="std std-ref">create_mpi_comm</span></a>
and <a class="reference internal" href="#sec-calc-params"><span class="std std-ref">calc_params</span></a> are described in more detail below, but
the basic idea is to create a topologically aware communicator so each process
knows its position in the domain and to try to distrubute the work to each process
in an equitable manner while taking into account the fact that the DAB updates
are more expensive than the Yee updates.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// create cartesian communicator</span>
<span class="n">create_mpi_comm</span><span class="p">(</span><span class="n">glob_comm</span><span class="p">);</span>

<span class="c1">// calculate grid and time step size</span>
<span class="k">if</span> <span class="p">(</span><span class="n">grid_comm</span> <span class="o">!=</span> <span class="n">MPI_COMM_NULL</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">try</span> <span class="p">{</span>
    <span class="n">calc_params</span><span class="p">();</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;id = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">my_id</span>
      <span class="o">&lt;&lt;</span> <span class="s">&quot; failed in calc_params() --- a standard exception was caught, with message &#39;&quot;</span>
      <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">MPI_Abort</span><span class="p">(</span><span class="n">glob_comm</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// wait for all processes to finish calculating parameters</span>
  <span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">grid_comm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Next we allocate the bulk of the memory for the field values. Note that we do not
allocate the send and receive buffers here (it would be a good idea to do so).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// allocate memory</span>
<span class="k">if</span> <span class="p">(</span><span class="n">grid_comm</span> <span class="o">!=</span> <span class="n">MPI_COMM_NULL</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">try</span> <span class="p">{</span>
    <span class="n">allocate_memory</span><span class="p">();</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;id = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">my_id</span>
      <span class="o">&lt;&lt;</span> <span class="s">&quot; failed in allocate_memory() --- a standard exception was caught, with message &#39;&quot;</span>
      <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">MPI_Abort</span><span class="p">(</span><span class="n">glob_comm</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// wait for all processes to finish allocating memory</span>
  <span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">grid_comm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We now initialize the boundary updater objects using the DAB library</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// initialize DAB updaters</span>
<span class="k">if</span> <span class="p">(</span><span class="n">grid_comm</span> <span class="o">!=</span> <span class="n">MPI_COMM_NULL</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">try</span> <span class="p">{</span>
    <span class="n">init_DAB</span><span class="p">();</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;id = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">my_id</span>
      <span class="o">&lt;&lt;</span> <span class="s">&quot; failed in init_DAB() --- a standard exception was caught, with message &#39;&quot;</span>
      <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">MPI_Abort</span><span class="p">(</span><span class="n">glob_comm</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// wait for all processes to set up DAB updaters (if needed)</span>
  <span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">grid_comm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, we set up the solution routine. The solution we will use is described
in the <a class="reference internal" href="results.html"><span class="doc">numerical results page</span></a> and the code is availabe at
<a class="reference external" href="https://github.com/jrlagrone/rbcpack/blob/main/YeeCRBC/examples/yee_mpi/solutions.cpp">solutions.cpp</a>
and <a class="reference external" href="https://github.com/jrlagrone/rbcpack/blob/main/YeeCRBC/examples/yee_mpi/solutions.hpp">solutions.hpp</a>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// set up the solution routine</span>
<span class="k">if</span> <span class="p">(</span><span class="n">grid_comm</span> <span class="o">!=</span> <span class="n">MPI_COMM_NULL</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">try</span> <span class="p">{</span>
    <span class="n">init_solutions</span><span class="p">();</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;id = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">my_id</span>
      <span class="o">&lt;&lt;</span> <span class="s">&quot; failed in init_solutions() --- a standard exception was caught, with message &#39;&quot;</span>
      <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">MPI_Abort</span><span class="p">(</span><span class="n">glob_comm</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// wait for all processes to set up solution routines</span>
  <span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">grid_comm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="routine-to-run-the-simulation">
<h3>Routine to run the Simulation<a class="headerlink" href="#routine-to-run-the-simulation" title="Permalink to this headline">¶</a></h3>
<p>The following routine is responsible for running the actual simulation. It starts
by determining how many time steps to take between outputs and reserves memory
to save these outputs. Then the initial conditions are load and we calculate the
norm of the initial data so we can calculate relative errors later.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">run</span><span class="p">()</span>
<span class="p">{</span>

  <span class="kt">double</span> <span class="n">loc_norm</span><span class="p">,</span> <span class="n">glob_norm</span><span class="p">,</span> <span class="n">loc_err</span><span class="p">,</span> <span class="n">glob_err</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">tskip</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">tstep</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">err</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">time</span><span class="p">;</span>

  <span class="c1">// figure out how many time steps should be taken between outputs</span>
  <span class="n">tskip</span> <span class="o">=</span> <span class="n">io_t</span><span class="o">/</span><span class="n">dt</span><span class="p">;</span>

  <span class="c1">// reserve memory for errors</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">my_id</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">err</span><span class="p">.</span><span class="n">reserve</span><span class="p">((</span><span class="n">ntsteps</span> <span class="o">/</span> <span class="n">tskip</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">time</span><span class="p">.</span><span class="n">reserve</span><span class="p">((</span><span class="n">ntsteps</span> <span class="o">/</span> <span class="n">tskip</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// load initial conditions</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">grid_comm</span> <span class="o">!=</span> <span class="n">MPI_COMM_NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">try</span> <span class="p">{</span>
      <span class="n">load_initial_conds</span><span class="p">();</span>
    <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;id = &quot;</span>
        <span class="o">&lt;&lt;</span> <span class="n">my_id</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; failed in load_initial_conds() --- a standard exception was caught, with message &#39;&quot;</span>
        <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">MPI_Abort</span><span class="p">(</span><span class="n">glob_comm</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">grid_comm</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// calculate norm of intitial conditions</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">grid_comm</span> <span class="o">!=</span> <span class="n">MPI_COMM_NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">try</span> <span class="p">{</span>
      <span class="n">loc_norm</span> <span class="o">=</span> <span class="n">calc_norm</span><span class="p">();</span>
    <span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;id = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">my_id</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot; failed in calc_norm() --- a standard exception was caught, with message &#39;&quot;</span>
        <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">MPI_Abort</span><span class="p">(</span><span class="n">glob_comm</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">grid_comm</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>Next we collect the norm (squared) from each of the processes onto a single process
using MPI_Reduce.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// use mpi_reduce to calculate global norm</span>
<span class="n">glob_norm</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">grid_comm</span> <span class="o">!=</span> <span class="n">MPI_COMM_NULL</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Reduce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loc_norm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">glob_norm</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="n">MPI_SUM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">grid_comm</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Reduce failed, norm calculation&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">my_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">glob_norm</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">glob_norm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Next we actually run the simulation by time stepping. The idea here is that we
have discretized the problem in such a way that we can update all of the internal
E-Field values, so we do that first. After the internal E-field values are updated
we send any values needed on the boundaries between processes and begin updating
exterior boundaries using the DAB library. We send the DAB values as soon as they are
available and then update the internal H-field while waiting to receive the E-field
needed to update the boundaries. After receiving the E-field and DAB updates from
neighboring processes, we update the H-fields along the boundaries. We repeat this
process and calculate the error at the requesting intervals until we reach the
final time.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// time step</span>
<span class="k">if</span> <span class="p">(</span><span class="n">grid_comm</span> <span class="o">!=</span> <span class="n">MPI_COMM_NULL</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">tstep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tstep</span> <span class="o">&lt;</span> <span class="n">ntsteps</span><span class="p">;</span> <span class="o">++</span><span class="n">tstep</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// generate output</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tstep</span> <span class="o">%</span> <span class="n">tskip</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// calculate error</span>
      <span class="n">loc_err</span> <span class="o">=</span> <span class="n">calc_error</span><span class="p">();</span>

      <span class="n">glob_err</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Reduce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loc_err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">glob_err</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="n">MPI_SUM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">grid_comm</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Reduce failed, err calculation&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">my_id</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;tstep = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">tstep</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; T (E) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Etime</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;      err = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">glob_err</span><span class="p">)</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;      rel err = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">glob_err</span><span class="p">)</span><span class="o">/</span><span class="n">glob_norm</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">err</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">glob_err</span><span class="p">));</span>
        <span class="n">time</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Etime</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="c1">// output</span>

    <span class="c1">// update E fields</span>
    <span class="n">step_E</span><span class="p">();</span>

    <span class="c1">// Send the E fields</span>
    <span class="n">send_E</span><span class="p">();</span>

    <span class="c1">// update the DAB</span>
    <span class="n">step_DAB</span><span class="p">();</span>

    <span class="c1">// update the current E time</span>
    <span class="n">Etime</span> <span class="o">+=</span> <span class="n">dt</span><span class="p">;</span>

    <span class="c1">// Send the DAB values</span>
    <span class="n">send_DAB</span><span class="p">();</span>

    <span class="c1">// update the H fields</span>
    <span class="n">step_inner_H</span><span class="p">();</span>

    <span class="c1">// wait for the E field sends to complete</span>
    <span class="n">recv_E</span><span class="p">();</span>

    <span class="c1">// wait for the DAB sends to complete</span>
    <span class="n">recv_DAB</span><span class="p">();</span>

    <span class="c1">// get the updated boundary values from the DAB updaters</span>
    <span class="n">copy_DAB</span><span class="p">();</span>

    <span class="c1">// update the boundary H fields</span>
    <span class="n">step_outer_H</span><span class="p">();</span>

    <span class="c1">// increment H time</span>
    <span class="n">Htime</span> <span class="o">+=</span> <span class="n">dt</span><span class="p">;</span>

    <span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">grid_comm</span><span class="p">);</span>

  <span class="p">}</span> <span class="c1">// end time stepping</span>
</pre></div>
</div>
<p>Ater the time stepping is complete, we compute the error at the final time and
output all of the error data again in a comma seperated list that is easily
imported into other programs.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// calculate final error</span>
<span class="n">loc_err</span> <span class="o">=</span> <span class="n">calc_error</span><span class="p">();</span>

<span class="n">glob_err</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">MPI_Reduce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loc_err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">glob_err</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="n">MPI_SUM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">grid_comm</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Reduce failed, err calculation&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">my_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">err</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">glob_err</span><span class="p">));</span>
  <span class="n">time</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Etime</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;tstep = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">tstep</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;     T (E) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Etime</span>
    <span class="o">&lt;&lt;</span> <span class="s">&quot;    err = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">glob_err</span><span class="p">)</span>
    <span class="o">&lt;&lt;</span> <span class="s">&quot;    rel err = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">(</span><span class="n">glob_err</span><span class="p">)</span><span class="o">/</span><span class="n">glob_norm</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// print out all the errors again that are easier to import</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;time, error, relative error,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">err</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">time</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span>  <span class="o">&lt;&lt;</span> <span class="n">err</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">glob_norm</span>
      <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-free-communicators">
<h3>Function to Free Communicators<a class="headerlink" href="#function-to-free-communicators" title="Permalink to this headline">¶</a></h3>
<p>To avoid memory leaks, we define a function to free the communicators. We note
that it may be better practice to have the class call MPI_Init and put the following
code along with a call to MPI_Finalize in the class destructor.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">free_comms</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">MPI_Comm_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">glob_comm</span><span class="p">);</span>
  <span class="n">MPI_Comm_free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grid_comm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-print-approximate-memory-usage">
<h3>Function to Print Approximate Memory Usage<a class="headerlink" href="#function-to-print-approximate-memory-usage" title="Permalink to this headline">¶</a></h3>
<p>The following function is potentially useful in analyzing the load balancing and
reports a list of how much memory is used by each process.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">print_mem_use</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">grid_comm</span> <span class="o">!=</span> <span class="n">MPI_COMM_NULL</span><span class="p">)</span> <span class="p">{</span>

    <span class="kt">double</span> <span class="n">tot_mem_use</span><span class="p">,</span> <span class="n">dab_buff</span><span class="p">,</span> <span class="n">ebuff</span><span class="p">,</span> <span class="n">fields</span><span class="p">;</span>

    <span class="c1">// calculate the size of the field vectors in MB</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">capacity</span><span class="p">()</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">capacity</span><span class="p">()</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">capacity</span><span class="p">()</span> <span class="o">+</span>
        <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">capacity</span><span class="p">()</span> <span class="o">+</span> <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">capacity</span><span class="p">()</span> <span class="o">+</span> <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">capacity</span><span class="p">())</span> <span class="o">/</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>

    <span class="c1">// calculate the size of the E send/recieve buffers</span>
    <span class="n">ebuff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="n">ebuff</span> <span class="o">+=</span>  <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">E_sbuf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">capacity</span><span class="p">()</span> <span class="o">+</span> <span class="n">E_rbuf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">capacity</span><span class="p">())</span> \
          <span class="o">/</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>

    <span class="c1">// calculate the size of the DAB buffers</span>
    <span class="n">dab_buff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="n">dab_buff</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">DAB_sbuf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">capacity</span><span class="p">()</span> <span class="o">+</span> <span class="n">DAB_rbuf</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">capacity</span><span class="p">())</span> \
              <span class="o">/</span> <span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">);</span>

    <span class="c1">// calculate total mem use (dab_mem_use is calculate in init_DAB())</span>
    <span class="n">tot_mem_use</span> <span class="o">=</span> <span class="n">dab_buff</span> <span class="o">+</span> <span class="n">ebuff</span> <span class="o">+</span> <span class="n">fields</span> <span class="o">+</span> <span class="n">dab_mem_use</span><span class="p">;</span>

    <span class="c1">// colect everything on 1 process</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">send</span><span class="p">,</span> <span class="n">recv</span><span class="p">;</span>
    <span class="n">send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">dab_buff</span><span class="p">);</span>
    <span class="n">send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ebuff</span><span class="p">);</span>
    <span class="n">send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">fields</span><span class="p">);</span>
    <span class="n">send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">dab_mem_use</span><span class="p">);</span>
    <span class="n">send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tot_mem_use</span><span class="p">);</span>
    <span class="n">recv</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">nprocs_cubed</span><span class="o">*</span><span class="mi">5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Gather</span><span class="p">(</span><span class="n">send</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="mi">5</span><span class="p">,</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="n">recv</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="mi">5</span><span class="p">,</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">grid_comm</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Gather failed &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">my_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; , DAB Buffers, E Buffers, Fields, DAB, Total&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">nprocs_cubed</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;proc &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">l</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
           <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">recv</span><span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="n">l</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Total, &quot;</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">tot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">nprocs_cubed</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span>
          <span class="n">tot</span> <span class="o">+=</span> <span class="n">recv</span><span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="n">l</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tot</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// end my_id == 0</span>
  <span class="p">}</span> <span class="c1">// end if grid_comm != MPI_COMM_NULL</span>
<span class="p">}</span> <span class="c1">// end print_mem_use()</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-print-timing-data">
<h3>Function to Print Timing Data<a class="headerlink" href="#function-to-print-timing-data" title="Permalink to this headline">¶</a></h3>
<p>This function prints a list of time each process spends in certain sections of the
code both in seconds and as a percentage. The first table is the actual times
and the second table is the percentage of time spend in each section.
Note the row totals can be viewed as wall times and the column totals are CPU times.
Again, this function is potentially useful in analyzing the load balancing.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">print_timing_data</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">grid_comm</span> <span class="o">!=</span> <span class="n">MPI_COMM_NULL</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">timers_send</span><span class="p">,</span> <span class="n">timers_recv</span><span class="p">;</span>

    <span class="n">timers_send</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">15</span><span class="p">);</span>
    <span class="n">timers_recv</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="mi">15</span><span class="o">*</span><span class="n">nprocs_cubed</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>

    <span class="c1">// save all the local timers to a vector</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">calc_params_t</span><span class="p">);</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">create_comm_t</span><span class="p">);</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">alloc_mem_t</span><span class="p">);</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">init_dab_t</span><span class="p">);</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">step_E_t</span><span class="p">);</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">step_inner_H_t</span><span class="p">);</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">step_outer_H_t</span><span class="p">);</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">step_DAB_t</span><span class="p">);</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">send_DAB_t</span><span class="p">);</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">recv_DAB_t</span><span class="p">);</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">send_E_t</span><span class="p">);</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">recv_E_t</span><span class="p">);</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">load_init_conds_t</span><span class="p">);</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">calc_norm_t</span><span class="p">);</span>
    <span class="n">timers_send</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">calc_err_t</span><span class="p">);</span>

    <span class="c1">// gather all timer data</span>
    <span class="n">MPI_Gather</span><span class="p">(</span><span class="n">timers_send</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">timers_send</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="n">timers_recv</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">timers_send</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">grid_comm</span><span class="p">);</span>

    <span class="c1">// print out timer data</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">my_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; ,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Calculating Parameters,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Creating Communicators,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Allocating Memory,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Initializing DABs,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Stepping E,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Stepping Inner H,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Stepping Outer H,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Stepping DAB,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Sending DAB,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Receiving DAB,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Sending E,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Receiving E,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Loading Initial Condition,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Calculating Norm,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Calculating Error,&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; Total &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

      <span class="n">timers_send</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nprocs_cubed</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">timers_recv</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">15</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">timers_recv</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">15</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>

        <span class="c1">// print timer data for each process</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; process &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
          <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">timers_recv</span><span class="p">[</span><span class="mi">15</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="c1">// update total times</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
          <span class="n">timers_send</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">timers_recv</span><span class="p">[</span><span class="mi">15</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>
        <span class="n">timers_send</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; Total &quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">timers_send</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">timers_send</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

      <span class="c1">// compute percentages</span>
      <span class="n">timers_send</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nprocs_cubed</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; process &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
          <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">100</span><span class="o">*</span><span class="n">timers_recv</span><span class="p">[</span><span class="mi">15</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">timers_recv</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">15</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">timers_recv</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">15</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;100&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="c1">// total percentages</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
          <span class="n">timers_send</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">timers_recv</span><span class="p">[</span><span class="mi">15</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">timers_recv</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">15</span><span class="o">*</span><span class="n">i</span><span class="p">,</span>   <span class="n">timers_recv</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">15</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
        <span class="n">timers_send</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; Average &quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="mi">100</span><span class="o">*</span><span class="n">timers_send</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">nprocs_cubed</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// end if id == 0</span>
  <span class="p">}</span> <span class="c1">// end comm check</span>
<span class="p">}</span> <span class="c1">// end print_timing_data</span>
</pre></div>
</div>
</div>
<div class="section" id="routine-to-calculate-parameters">
<span id="sec-calc-params"></span><h3>Routine to Calculate Parameters<a class="headerlink" href="#routine-to-calculate-parameters" title="Permalink to this headline">¶</a></h3>
<p>The main purpose of this routine is to do some basic load balancing. The idea
that using P auxilliary variables is roughly equal (in terms of FLOPS) to
doing ~3*P Yee cell updates, so we will make the processes with DAB layers have
fewer Yee updates to compute but otherwise distribute the points as evenly as
possible. Note that the difference between the DAB and Yee memory access patterns
probably plays a role here, but we’re ignoring it.</p>
<p>Also note that we are overlaping the processor domains by a factor of h.
This is certainly less memory efficient, but it makes the message
passing and updates a bit more straightforward.</p>
<p>We begin by defining the bottom left corner of the domain, which we assume to be
a cube centered around 0 and compute the grid spacing.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">calc_params</span><span class="p">()</span>
<span class="p">{</span>

  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">rem</span><span class="p">,</span> <span class="n">n</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">P</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>

  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>  <span class="c1">// start timer</span>

  <span class="c1">// use the requested number of recursoins</span>
  <span class="n">P</span> <span class="o">=</span> <span class="n">CRBC_P</span><span class="p">;</span>

  <span class="c1">// compute the left-most point in each coordinate direction</span>
  <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">domain_width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
  <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">domain_width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
  <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">domain_width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>

  <span class="n">h</span> <span class="o">=</span> <span class="n">domain_width</span><span class="o">/</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="p">(</span><span class="n">n_global</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">));</span>
</pre></div>
</div>
<p>Next, if we only have a single process we just compute the number of grid points
on that process by setting them to the number of points requested.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">nprocs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// if there&#39;s only 1 MPI process, we just compute the number of grid points</span>
  <span class="c1">// like normal</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_global</span><span class="p">;</span>
</pre></div>
</div>
<p>Otherwise, we start by calculating the total number of “grid points” assuming that
each additional auxilliary variable in the DAB counts for <span class="math notranslate nohighlight">\(dab\_wt\)</span> grid
points. We additionally assume that each of the exterior boundaries is in fact
a DAB, that is we assume the free space problem. We also assume the
grid overlaps by a factor of h so processes share 2 grid points with their neighbors.
That is, we want the domain to look something like</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">......</span>       <span class="p">...........</span>       <span class="p">...........</span>       <span class="p">......</span>
    <span class="p">...........</span>       <span class="p">...........</span>       <span class="p">...........</span>
</pre></div>
</div>
<p>So if we had a single process we would have n_global points plus there are 2 DABS,
which give <span class="math notranslate nohighlight">\(2 \cdot P \cdot dab\_wt\)</span> points plus we have the extra points due to overlapping
the grid, which gives <span class="math notranslate nohighlight">\(2(nprocs-1)\)</span> points putting this all together, we get
that we need a total of <span class="math notranslate nohighlight">\(n\_global + 2 \cdot P \cdot dab\_wt + 2 \cdot nprocs -2\)</span>.
We try to divide this up evenly and calculate how many points are left over.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>


  <span class="c1">//</span>
  <span class="c1">// IMPORTANT:</span>
  <span class="c1">// This can fail by making processes have too few points on the boundary or</span>
  <span class="c1">// or even assigning a negative number of points on the boundary processes.</span>
  <span class="c1">// This isn&#39;t really accounted for, but we attempt to abort if we see it ...</span>
  <span class="n">x</span> <span class="o">=</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">n_global</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dab_wt</span><span class="o">*</span><span class="n">P</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nprocs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">nprocs</span><span class="p">;</span>
  <span class="n">rem</span> <span class="o">=</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">n_global</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">dab_wt</span><span class="o">*</span><span class="n">P</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">nprocs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))</span> <span class="o">%</span> <span class="n">nprocs</span><span class="p">;</span>

  <span class="c1">// Next we allocate points to processes in each direction bases on whether</span>
  <span class="c1">// they are on the boundary or not</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">cart_rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">cart_rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nprocs</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>

      <span class="c1">// if the process is on the boundary, we subtract of dab_wt*P points</span>
      <span class="c1">// to account for the DAB layer. We additionally calculate the left</span>
      <span class="c1">// most coordinate in this direction. Note that on the left side, we</span>
      <span class="c1">// have already correctly set this value so we only do it if it is the</span>
      <span class="c1">// right-most process</span>
      <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">dab_wt</span><span class="o">*</span><span class="n">P</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cart_rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">nprocs</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">dab_wt</span><span class="o">*</span><span class="n">P</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">h</span> <span class="o">+</span> <span class="p">(</span><span class="n">cart_rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">h</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

      <span class="c1">// otherwise, we just assign the number of points as is and calculate</span>
      <span class="c1">// the left-most point of the process in the current direction</span>
      <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
      <span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">dab_wt</span><span class="o">*</span><span class="n">P</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">h</span> <span class="o">+</span> <span class="p">(</span><span class="n">cart_rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">h</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>It is possible that the number of “points” generated above does not divide evenly
across the processes. In this case, we just loop over the interior processes and add one
point to the current process and adjust the physical coordinates of each process
until we have used all of the extra points.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// now account for any left over points</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nprocs</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// if there are only 2 processes per direction, just add the extra point(s)</span>
    <span class="c1">// to the left process and shift the right process&#39; coordinates accordingly.</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cart_rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rem</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">rem</span><span class="o">*</span><span class="n">h</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

    <span class="c1">// otherwise we only add extra points to the interior processes. We do</span>
    <span class="c1">// this by looping over the interior processes from left to right and</span>
    <span class="c1">// add one to the current process and the coordinates by h for all of the</span>
    <span class="c1">// processes to the right and repeat until we have no remaining points.</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rem</span><span class="p">;</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rem</span><span class="p">;</span>
    <span class="n">r</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">rem</span><span class="p">;</span>

    <span class="c1">// loop over the number of remaining points just to make sure we iterate</span>
    <span class="c1">// enough times</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">rem</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// loop over the interior processes</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nprocs</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// loop over the directions</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// if we have points left, add one to the current process and shift</span>
          <span class="c1">// the process coordinates for the processes to the right</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cart_rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cart_rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">)</span>
              <span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">h</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="c1">// end for k</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, we do a simple check to make sure that the grid partitioning is somewhat
reasonable in the sense that each process will have at least 1 internal point.
We also calculate the time step size and set the initial times.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// do a basic check to make sure that the grid partitioning is somewhat</span>
<span class="c1">// reasonable</span>
<span class="k">if</span> <span class="p">((</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">))</span> <span class="p">{</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Grid partitioning failed. Try increasing n, decrreasing dab_wt, and/or nprocs&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">MPI_Abort</span><span class="p">(</span><span class="n">glob_comm</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// save the number of grid points in each direction</span>
<span class="n">nx</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">ny</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">nz</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="c1">// calculate the time step size and number of time steps</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.99</span> <span class="o">/</span> <span class="n">sqrt</span><span class="p">(</span><span class="mf">3.0</span><span class="o">/</span><span class="p">(</span><span class="n">h</span><span class="o">*</span><span class="n">h</span><span class="p">));</span>
<span class="n">ntsteps</span> <span class="o">=</span> <span class="n">T</span> <span class="o">/</span> <span class="n">dt</span><span class="p">;</span>
<span class="n">Etime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Htime</span> <span class="o">=</span> <span class="n">dt</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>

<span class="c1">// update timer</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
<span class="n">calc_params_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-create-a-mpi-communicator">
<span id="sec-create-mpi-comm"></span><h3>Function to Create a MPI Communicator<a class="headerlink" href="#function-to-create-a-mpi-communicator" title="Permalink to this headline">¶</a></h3>
<p>This function creates a topologically aware MPI communicator and figures out the
neighbors and boundary conditions on each process. We start by creating the
a Cartesian communicator using the build in MPI function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">create_mpi_comm</span><span class="p">(</span><span class="n">MPI_Comm</span> <span class="n">comm</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">periods</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">diag_coords</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">diag_rank</span><span class="p">;</span>
  <span class="n">periods</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// not periodic</span>
  <span class="n">periods</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">periods</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">reorder</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>

  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span> <span class="c1">// start timer</span>

  <span class="kt">int</span> <span class="n">dims</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nprocs</span><span class="p">;</span>
  <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nprocs</span><span class="p">;</span>
  <span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nprocs</span><span class="p">;</span>

  <span class="n">nprocs_cubed</span> <span class="o">=</span> <span class="n">nprocs</span><span class="o">*</span><span class="n">nprocs</span><span class="o">*</span><span class="n">nprocs</span><span class="p">;</span>

  <span class="c1">// create a cartesian communicator with nprocs in each direction</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Cart_create</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">reorder</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">grid_comm</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Cart_create failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>Next we figure out the the neighboring processes in each direction using the MPI_Cart_shift
function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// figure out neighboring processes</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="n">MPI_DIR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">MPI_PROC_NULL</span><span class="p">;</span>

<span class="n">cart_rank</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">cart_rank</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="n">cart_rank</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">grid_comm</span> <span class="o">!=</span> <span class="n">MPI_COMM_NULL</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">grid_comm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_id</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Comm_rank failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Cart_coords</span><span class="p">(</span><span class="n">grid_comm</span><span class="p">,</span> <span class="n">my_id</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">cart_rank</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Cart_coords failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// figure the ids of the processes we might need to send data to</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Cart_shift</span><span class="p">(</span><span class="n">grid_comm</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Cart_shift failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Cart_shift</span><span class="p">(</span><span class="n">grid_comm</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Cart_shift failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Cart_shift</span><span class="p">(</span><span class="n">grid_comm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Cart_shift failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>
</div>
<p>Then, we figure out which of the processes are on the boundary. We do this based
on whether or not the process has a neighbor, but it could also be done using the
coordinates of the processes on the Cartesian communicator. We are assuming the
free space problem, so in each direction we label the boundary to by type <code class="docutils literal notranslate"><span class="pre">CRBC</span></code>
for exterior boundaries and <code class="docutils literal notranslate"><span class="pre">NONE</span></code> for interior boundaries shared with another
process.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// figure out which processes are on the boundary</span>
<span class="n">isBoundaryProc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="c1">// if a process doesn&#39;t have a neighbor on at least 1 side, its on the boundary</span>
<span class="k">if</span> <span class="p">((</span><span class="n">grid_comm</span> <span class="o">!=</span> <span class="n">MPI_COMM_NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span> <span class="o">||</span>
     <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span> <span class="o">||</span>
     <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span> <span class="o">||</span>
     <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="n">MPI_PROC_NULL</span><span class="p">)))</span>
  <span class="n">isBoundaryProc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="c1">// label the boundaries. Use type NONE for interior sides and CRBC for the</span>
<span class="c1">// exterior boundaries. To do a wave guide, e.g., one might change the type</span>
<span class="c1">// to DIR on the appropriate sides</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">procBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">grid_comm</span> <span class="o">!=</span> <span class="n">MPI_COMM_NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">MPI_PROC_NULL</span><span class="p">))</span>
    <span class="n">procBounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finalling, we figure out which edges are shared between processes so we can send
data diagonally to complete the edge updates.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// figure out if we need to send any edge data diagonally</span>
<span class="k">if</span> <span class="p">(</span><span class="n">grid_comm</span> <span class="o">!=</span> <span class="n">MPI_COMM_NULL</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// loop over sides</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// get a second side to check</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// make sure the sides are not parallel</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span> <span class="o">!=</span> <span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MPI_PROC_NULL</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">send_edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">});</span>

          <span class="c1">// get rank of destination</span>
          <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span>
            <span class="n">diag_coords</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">cart_rank</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
          <span class="c1">// shift coordinate for first side</span>
          <span class="n">diag_coords</span><span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">cart_rank</span><span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">cart_rank</span><span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
          <span class="c1">// shift coordinate for second side</span>
          <span class="n">diag_coords</span><span class="p">[</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">cart_rank</span><span class="p">[</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">cart_rank</span><span class="p">[</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Cart_rank</span><span class="p">(</span><span class="n">grid_comm</span><span class="p">,</span> <span class="n">diag_coords</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">diag_rank</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Cart_rank failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

          <span class="n">MPI_EDGE_DIR</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">diag_rank</span><span class="p">);</span>

        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// stop timer</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
<span class="n">create_comm_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-initialize-solutions">
<h3>Function to Initialize Solutions<a class="headerlink" href="#function-to-initialize-solutions" title="Permalink to this headline">¶</a></h3>
<p>Here, we define a function which initializes the solution routines. We simply
provide a source location, which we place at (0,0,0) and we give it the grid
spacing, material parameters, <span class="math notranslate nohighlight">\(\mu\)</span> and <span class="math notranslate nohighlight">\(\varepsilon\)</span>, and the
parameters that determine the width and start time of the Gaussian pulse,
<span class="math notranslate nohighlight">\(\gamma\)</span> and :math`tau`.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">init_solutions</span><span class="p">()</span>
<span class="p">{</span>

  <span class="kt">double</span> <span class="n">src_loc</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">hloc</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

  <span class="c1">// place the source at (0,0,0)a small perturbation to decrease the</span>
  <span class="c1">// chances of coinciding with a grid point may be needed. If the source is on a grid</span>
  <span class="c1">// point there is the possiblity of a division by zero in the solution</span>
  <span class="c1">// routines</span>
  <span class="n">src_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="n">src_loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="n">src_loc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

  <span class="c1">// set the grid spacing to be the same in all directions</span>
  <span class="n">hloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
  <span class="n">hloc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
  <span class="n">hloc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>

  <span class="c1">// initialize the solution object</span>
  <span class="n">sol_obj</span> <span class="o">=</span> <span class="n">maxwell_solutions</span><span class="o">::</span><span class="n">MW_FreeSpace</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">src_loc</span><span class="p">);</span>
  <span class="n">sol_obj</span><span class="p">.</span><span class="n">set_grid_spacing</span><span class="p">(</span><span class="n">hloc</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-allocate-memory">
<h3>Function to Allocate Memory<a class="headerlink" href="#function-to-allocate-memory" title="Permalink to this headline">¶</a></h3>
<p>This function allocates memory for each of the field components. We note it would
likely be a good idea to allocate the send and receive buffers here as well.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">allocate_memory</span><span class="p">()</span>
<span class="p">{</span>

  <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>

  <span class="c1">// start timer</span>
  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

  <span class="c1">// figure out the largest number number of grid points possible</span>
  <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">nx</span> <span class="o">&gt;</span> <span class="n">ny</span><span class="p">)</span> <span class="o">?</span> <span class="nl">nx</span> <span class="p">:</span> <span class="n">ny</span><span class="p">;</span>
  <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="n">nz</span><span class="p">)</span> <span class="o">?</span> <span class="nl">m</span> <span class="p">:</span> <span class="n">nz</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Allreduce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">maxn</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">MPI_INT</span><span class="p">,</span> <span class="n">MPI_MAX</span><span class="p">,</span> <span class="n">grid_comm</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Allreduce failed&quot;</span><span class="p">;</span>

  <span class="c1">// allocate Fields and initialize to 0</span>
  <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">assign</span><span class="p">((</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">ny</span><span class="o">*</span><span class="n">nz</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>     <span class="c1">// Ex</span>
  <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">assign</span><span class="p">(</span><span class="n">nx</span><span class="o">*</span><span class="p">(</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nz</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>     <span class="c1">// Ey</span>
  <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">assign</span><span class="p">(</span><span class="n">nx</span><span class="o">*</span><span class="n">ny</span><span class="o">*</span><span class="p">(</span><span class="n">nz</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>     <span class="c1">// Ez</span>
  <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">assign</span><span class="p">(</span><span class="n">nx</span><span class="o">*</span><span class="p">(</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">nz</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Hx</span>
  <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">assign</span><span class="p">((</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">ny</span><span class="o">*</span><span class="p">(</span><span class="n">nz</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Hy</span>
  <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">assign</span><span class="p">((</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nz</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span> <span class="c1">// Hz</span>

  <span class="c1">// compute update coefficients</span>
  <span class="n">Hcoef</span> <span class="o">=</span> <span class="p">(</span><span class="n">dt</span><span class="o">/</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="n">h</span><span class="p">;</span>
  <span class="n">Ecoef</span> <span class="o">=</span> <span class="p">(</span><span class="n">dt</span><span class="o">/</span><span class="n">eps</span><span class="p">)</span><span class="o">/</span><span class="n">h</span><span class="p">;</span>

  <span class="c1">// stop timer</span>
  <span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
  <span class="n">alloc_mem_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-initilize-the-dab-layer">
<h3>Function to Initilize the DAB Layer<a class="headerlink" href="#function-to-initilize-the-dab-layer" title="Permalink to this headline">¶</a></h3>
<p>The purpose of this function is to set up objects to provide the exterior
boudnary updates using the DAB library. Again, we are assuming this is a free
space problem, so we initialize DAB updaters for each of the 3 E-field components.
Note, in a wave guide, for example, where there are no DAB edges or corners, we only
need updaters for the tangential components. There’s no harm in having an updater
for the normal components when it’s not needed, but it represents unnecessary work.</p>
<p>We overlap the DAB domains so that each process can update the information it needs
to continue with the DAB library. If we did not overlap the domains, we would need
to pass data used in the DAB library between neighboring processes at the wave equation
stage of the DAB update. This is possible to do, but it would require changing
the inner workings of the DAB library.</p>
<p>We start by creating storage for various properties of the DAB that we may want
to print out such as the error estimates.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">init_DAB</span><span class="p">()</span>
<span class="p">{</span>

  <span class="kt">double</span> <span class="n">delta</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">low</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">high</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">htmp</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="n">htmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">htmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">htmp</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>

  <span class="c1">// start timer</span>
  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

  <span class="c1">// storage for DAB boundary properties that we might want to print out or need</span>
  <span class="c1">// to use elsewhere</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">my_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rDAB_props</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="mi">15</span><span class="o">*</span><span class="n">nprocs_cubed</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
    <span class="n">rDAB_refl</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">nprocs_cubed</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">DAB_props</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="n">DAB_refl</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="n">DAB_refl</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">DAB_refl</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">DAB_refl</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</div>
<p>Next we check to see of the process is on the boundary. If it is, we initialize
a boundary updater object for each of the 3 E-field components. Here, we are thinking
of Ex = 0, Ey = 1, and Ez = 2. We provide the CRBC time parameter, the grid spacing,
time step size, wave speed, and the processor boundary types.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">isBoundaryProc</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// We initialize the updaters in 3D with double field values and ints for</span>
  <span class="c1">// indexing (and by default doubles for coeficients) and provide the run</span>
  <span class="c1">// time, grid spacing, time step size, wave speed, and boundary configuration</span>
  <span class="c1">// on each boundary process</span>
  <span class="n">bound_upd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">CrbcUpdates</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">CRBC_T</span><span class="p">,</span> <span class="n">htmp</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">procBounds</span><span class="p">);</span>
  <span class="n">bound_upd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">CrbcUpdates</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">CRBC_T</span><span class="p">,</span> <span class="n">htmp</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">procBounds</span><span class="p">);</span>
  <span class="n">bound_upd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">CrbcUpdates</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">CRBC_T</span><span class="p">,</span> <span class="n">htmp</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">procBounds</span><span class="p">);</span>
</pre></div>
</div>
<p>Then, we loop over and set up each of the possible boundary sides.</p>
<p>We are dealing with the message passing by overlapping the DAB layer for “simplicity.”
We recall that we over lapped the Yee grid so we an overlap of 2 grid points for
tangential components, so the grid looks like</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">Tangential</span> <span class="n">components</span>            <span class="n">Normal</span> <span class="n">Components</span>
  <span class="o">--------</span>                    <span class="o">---</span><span class="n">x</span><span class="o">-----</span><span class="n">x</span><span class="o">-----</span><span class="n">x</span><span class="o">---</span>
  <span class="n">x</span>   <span class="n">x</span>   <span class="n">x</span>                      <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>
  <span class="o">--------</span>                    <span class="o">---</span><span class="n">x</span><span class="o">-----</span><span class="n">x</span><span class="o">-----</span><span class="n">x</span><span class="o">---</span>
      <span class="o">--------</span>                            <span class="o">---</span><span class="n">x</span><span class="o">-----</span><span class="n">x</span><span class="o">-----</span><span class="n">x</span><span class="o">---</span>
      <span class="n">x</span>   <span class="n">x</span>   <span class="n">x</span>                              <span class="o">|</span>     <span class="o">|</span>     <span class="o">|</span>
      <span class="o">--------</span>                            <span class="o">---</span><span class="n">x</span><span class="o">-----</span><span class="n">x</span><span class="o">-----</span><span class="n">x</span><span class="o">---</span>
</pre></div>
</div>
<p>Note that the use of normal and tangential components here is somewhat
confusing because it is in reference to the boundaries with neighboring
processes, NOT the phyiscal boundary. We consider the direction in which
the message passing needs to take place as the normal direction. This
results in the following, e.g.</p>
<p>With our implementation, each process has components with the following
indexing bounds:</p>
<ul class="simple">
<li><p>Ex(0:nx-2, 0:ny-1, 0:nz-1) located at ((i+1/2)*h, j*h, k*h)</p></li>
<li><p>Ey(0:nx-1, 0:ny-2, 0:nz-1) located at (i*h, (j+1/2)*h, k*h)</p></li>
<li><p>Ez(0:nx-1, 0:ny-1, 0:nz-2) located at (i*h, j*h, (k+1/2)*h)</p></li>
</ul>
<p>So, for example, we’ll consider the right boundary face in the x
direction. Then, we potentially need to pass information North/South
in the y-direction) or Up/Down (in the z-direction). For the case of
needed to pass information in the North/South direction, the Ey
component is normal to the interface between the two processes and Ex and
Ez are tangential. The tangential components are already overlapped the way
we want because we overlapped the grids for the Yee scheme, therefore, we
tell the DAB updater the actual data extents for the points:</p>
<p>For Ex the proper extents are [nx-3, nx-2] x [0, ny-1] x [0, nz-1]
because we include all the points in the y and z directions and the point
in x on the physical boundary and it’s neighbor to the left.  Similary, for Ez
the extents are [nx-2, nx-1] x [0, ny-1] x [0, nz-2].</p>
<p>For Ey, if we do the same thing, we would get the extents
nx-2, nx-1] x [0, ny-2] x [0, nz-1], but this does not overlap the grids
by 2 points. To correct this, we tell the DAB layer that the extents are
greater than the actual data range by subtracting 1 from the lower y
extent if their is a neighboring process in the MPI_DIR[4] direction to get
[nx-2, nx-1] x [-1, ny-2] x [0, nz-1].</p>
<p>NOTE: the DAB updater considers the extents to be inclusive.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// figure out seperation from source</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">domain_width</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">;</span>

    <span class="c1">// loop over field components</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// generic extents that are close to correct (some of the indices are</span>
      <span class="c1">// off by a factor of 1, which depends on the component)</span>
      <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// left boundary in x, need [0,1] in x, all in y, z</span>
        <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">// adjust based on field component</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Ey</span>
            <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span>
            <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Ez</span>
            <span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span>
            <span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>

      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// right boundary in x, need [nx-2, nx-1] in x, all y, z</span>
        <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nx</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>

        <span class="c1">// adjust based on field component</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Ey</span>
            <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span>
            <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Ez</span>
            <span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span>
            <span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>

      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// left boundary in y, need [0,1] in y, all in x, z</span>
        <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">// adjust based on field component</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Ex</span>
            <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span>
            <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Ez</span>
            <span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span>
            <span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// right boundary in y, need [ny-2, ny-1] in y, all x, z</span>
        <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ny</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>

        <span class="c1">// adjust based on field component</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Ex</span>
            <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span>
            <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Ez</span>
            <span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span>
            <span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// left boundary in z, need [0,1] in z, all in x, y</span>
        <span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">// adjust based on field component</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Ex</span>
            <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span>
            <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Ey</span>
            <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span>
            <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// right boundary in z, need [nz-2, nz-1] in z, all x, y</span>
        <span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nz</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>

        <span class="c1">// adjust based on field component</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Ex</span>
            <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span>
            <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Ey</span>
            <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">MPI_PROC_NULL</span><span class="p">)</span>
            <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="c1">// call initializer and limit the number of recursions to at most 20</span>
      <span class="c1">// bound_upd[m].init_face(l, low, high, delta, 20, tol);</span>
      <span class="n">bound_upd</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">init_face</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">CRBC_P</span><span class="p">);</span>

    <span class="p">}</span> <span class="c1">// end loop over components</span>
  <span class="p">}</span>
<span class="p">}</span> <span class="c1">// end loop over sides</span>
</pre></div>
</div>
<p>Now we get and save properties such as estimated memory use, number of faces, edges,
and corners, and the error estimates from the DAB updater objects.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// now get some properties from the updaters that we may be interested in</span>
<span class="c1">// at a later time</span>
<span class="n">dab_mem_use</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">get_mem_usage</span><span class="p">()</span> <span class="o">+</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">get_mem_usage</span><span class="p">()</span> \
            <span class="o">+</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">get_mem_usage</span><span class="p">();</span>

<span class="c1">// get number of recursions and reflection coefficients</span>
<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">DAB_props</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">get_num_recursions</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
    <span class="n">DAB_refl</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">get_reflection_coef</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="n">DAB_refl</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">dab_mem_use</span><span class="p">;</span>

<span class="c1">// get info about the domain configuration</span>
<span class="n">DAB_props</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">get_num_faces</span><span class="p">();</span>
<span class="n">DAB_props</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">get_num_edges</span><span class="p">();</span>
<span class="n">DAB_props</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">get_num_corners</span><span class="p">();</span>
<span class="n">DAB_props</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">get_num_faces</span><span class="p">();</span>
<span class="n">DAB_props</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">get_num_edges</span><span class="p">();</span>
<span class="n">DAB_props</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">get_num_corners</span><span class="p">();</span>
<span class="n">DAB_props</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">get_num_faces</span><span class="p">();</span>
<span class="n">DAB_props</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">get_num_edges</span><span class="p">();</span>
<span class="n">DAB_props</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">get_num_corners</span><span class="p">();</span>
</pre></div>
</div>
<p>Finally, we call a function that figures out where we need to do message passing
to complete the DAB updates.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// figure out the message passing configuration</span>
<span class="n">calc_DAB_send_params</span><span class="p">();</span>

<span class="c1">// stop timer</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
<span class="n">init_dab_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-update-e-fields">
<h3>Function to Update E-Fields<a class="headerlink" href="#function-to-update-e-fields" title="Permalink to this headline">¶</a></h3>
<p>This function updates the E-field values and we note that it is identical to the
serial case with the exception that we do not update any points on the boundary.
This corresponds to doing the updates for a homogeneous Dirichlet boundary in
the serial case, but here the boundary values are calculated on a neighboring
process because we overlapped the domains or by the DAB boundary updater. We have
included option OpenMP here.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">step_E</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nxm</span><span class="p">,</span> <span class="n">nym</span><span class="p">,</span> <span class="n">nzm</span><span class="p">;</span>
  <span class="n">nxm</span> <span class="o">=</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">nym</span> <span class="o">=</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">nzm</span> <span class="o">=</span> <span class="n">nz</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>

  <span class="c1">// start timer</span>
  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

  <span class="cp">#if USE_OPENMP</span>
  <span class="cp">#pragma omp parallel default(shared) private(i,j,k)</span>
  <span class="p">{</span>
  <span class="cp">#endif</span>

    <span class="c1">// compute updates to Ex</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nzm</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nym</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nxm</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Ecoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">])</span> \
              <span class="o">-</span> <span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// compute updates to Ey</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nzm</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nym</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nxm</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Ecoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">])</span> \
              <span class="o">-</span> <span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// compute updates to Ez</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nzm</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nym</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nxm</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Ecoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">])</span> \
              <span class="o">-</span> <span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

  <span class="cp">#if USE_OPENMP</span>
  <span class="p">}</span> <span class="c1">// end parallel region</span>
  <span class="cp">#endif</span>

  <span class="c1">// stop timer</span>
  <span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
  <span class="n">step_E_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-compute-interior-h-field-updates">
<h3>Function to Compute Interior H-Field Updates<a class="headerlink" href="#function-to-compute-interior-h-field-updates" title="Permalink to this headline">¶</a></h3>
<p>Again, this function is identical to the serial case except we do not update the
H-fields on the boundaries because they depend on E-field values on the neighboring
process.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">step_inner_H</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nxm</span><span class="p">,</span> <span class="n">nym</span><span class="p">,</span> <span class="n">nzm</span><span class="p">;</span>
  <span class="n">nxm</span> <span class="o">=</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">nym</span> <span class="o">=</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">nzm</span> <span class="o">=</span> <span class="n">nz</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>

  <span class="c1">// start timer</span>
  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

  <span class="cp">#if USE_OPENMP</span>
  <span class="cp">#pragma omp parallel default(shared) private(i,j,k)</span>
  <span class="p">{</span>
  <span class="cp">#endif</span>

    <span class="c1">// compute updates to Hx</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nzm</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nym</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nxm</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Hcoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">])</span> \
                      <span class="o">-</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// compute updates to Hy</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nzm</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nym</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nxm</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Hcoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">])</span> \
                      <span class="o">-</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// compute updates to Hz</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nzm</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nym</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nxm</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Hcoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">])</span> \
                       <span class="o">-</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

  <span class="cp">#if USE_OPENMP</span>
  <span class="p">}</span>
  <span class="cp">#endif</span>

  <span class="c1">// stop timer</span>
  <span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
  <span class="n">step_inner_H_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="routine-to-update-boundary-h-fields">
<h3>Routine to Update Boundary H-Fields<a class="headerlink" href="#routine-to-update-boundary-h-fields" title="Permalink to this headline">¶</a></h3>
<p>After we have passed the E-fields from the neighboring processes, this function
computes the remaining H-field updates on the boundaries.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">step_outer_H</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nxm</span><span class="p">,</span> <span class="n">nym</span><span class="p">,</span> <span class="n">nzm</span><span class="p">;</span>
  <span class="n">nxm</span> <span class="o">=</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">nym</span> <span class="o">=</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">nzm</span> <span class="o">=</span> <span class="n">nz</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>

  <span class="c1">// start timer</span>
  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

  <span class="cp">#if USE_OPENMP</span>
  <span class="cp">#pragma omp parallel default(shared) private(i,j,k)</span>
  <span class="p">{</span>
  <span class="cp">#endif</span>

    <span class="c1">// compute updates to Hx</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nzm</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nym</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nx</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">nxm</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Hcoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">])</span> \
                       <span class="o">-</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nzm</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nym</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">nym</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nxm</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Hcoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">])</span> \
                      <span class="o">-</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nzm</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">nzm</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nym</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nxm</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Hcoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">])</span> \
                      <span class="o">-</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// compute updates to Hy</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nzm</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ny</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">nym</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nxm</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Hcoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">])</span> \
                       <span class="o">-</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nzm</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">nzm</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nym</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nxm</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Hcoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">])</span> \
                      <span class="o">-</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nzm</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nym</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nxm</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">nxm</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Hcoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">])</span> \
                       <span class="o">-</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// compute updates to Hz</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nz</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">nzm</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nym</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nxm</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Hcoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">])</span> \
                       <span class="o">-</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nzm</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nym</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">nym</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nxm</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Hcoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">])</span> \
                        <span class="o">-</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nzm</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nym</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nxm</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">nxm</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">+=</span> <span class="n">Hcoef</span> <span class="o">*</span> <span class="p">((</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">])</span> \
                        <span class="o">-</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

  <span class="cp">#if USE_OPENMP</span>
  <span class="p">}</span>
  <span class="cp">#endif</span>

  <span class="c1">// stop timer</span>
  <span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
  <span class="n">step_outer_H_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-update-the-dab-values">
<h3>Function to Update the DAB Values<a class="headerlink" href="#function-to-update-the-dab-values" title="Permalink to this headline">¶</a></h3>
<p>This function uses the DAB library to compute updated values on the boundaries.
This function does the same thing as the serial version on each process. In particular,
we ask the boundary update for the data extents of the inputs it needs from
the interior updates and then we copy those values into the DAB updater object.
The only thing different from the serial case is that sometimes the DAB updater
will request points that are not in the interior of the domain because we overlapped
the process domains. To fix this, we simply skip any negative indexes.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">step_DAB</span><span class="p">()</span>
<span class="p">{</span>

  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">nxm</span><span class="p">,</span> <span class="n">nym</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">low_ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">high_ind</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>

  <span class="c1">// start timer</span>
  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">isBoundaryProc</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// loop over the boundary faces</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// check to see if the current face is of type CRBC</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// loop over components</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>

          <span class="c1">// get the indices the updater object expects as input from this face.</span>
          <span class="c1">// Note that these values are inclusive</span>
          <span class="n">bound_upd</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">get_input_extents</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">low_ind</span><span class="p">,</span> <span class="n">high_ind</span><span class="p">);</span>

          <span class="c1">// Because we overlapped the grid the range may extend outside of the</span>
          <span class="c1">// field arrays. To fix this, we simply change -1 -&gt; 0 in the indexing</span>
          <span class="c1">// if it occurs.</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">low_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">low_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">low_ind</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

          <span class="c1">// set extents for loops Ex has nx-1 in the x-direction, Ey has ny-1 in y-dir.</span>
          <span class="n">nxm</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nx</span><span class="p">;</span>
          <span class="n">nym</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ny</span><span class="p">;</span>

          <span class="c1">// copy in the face values to the Ex faces</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">k</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                <span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
                <span class="n">bound_upd</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">load_face_data</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]);</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="c1">// end if crbc</span>
    <span class="p">}</span> <span class="c1">// end for</span>

    <span class="c1">// compute updates</span>
    <span class="n">bound_upd</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">compute_updates</span><span class="p">();</span>
    <span class="n">bound_upd</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">compute_updates</span><span class="p">();</span>
    <span class="n">bound_upd</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">compute_updates</span><span class="p">();</span>

  <span class="p">}</span> <span class="c1">// end isBoundaryProc</span>

  <span class="c1">// stop timer</span>
  <span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
  <span class="n">step_DAB_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-copy-updated-dab-values">
<h3>Function to Copy Updated DAB Values<a class="headerlink" href="#function-to-copy-updated-dab-values" title="Permalink to this headline">¶</a></h3>
<p>This function copies the updated values from the DAB updater to the interior of
the domain. Again, this is essentially identical to the serial case. We loop over
all of the updaters, ask them what the output extents are and skip any negative
indices that are caused by overlapping the grids. We also skip the normal
components because the values should already be correct from the Yee updates.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">copy_DAB</span><span class="p">()</span>
<span class="p">{</span>

  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">nxm</span><span class="p">,</span> <span class="n">nym</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">low_ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">high_ind</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>

  <span class="c1">// start timer</span>
  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">isBoundaryProc</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// now copy the updated values from the DAB back into the fields. We only</span>
    <span class="c1">// need to copy the tangential fields because the normal components should</span>
    <span class="c1">// already be correct from the Yee updates.</span>

    <span class="c1">// loop over the boundary faces</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// check to see if the current face is of type CRBC</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// loop over components</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>

          <span class="c1">// skip normal component</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>

          <span class="c1">// get the indices the updater object expects to output from this face.</span>
          <span class="c1">// Note that these values are inclusive</span>
          <span class="n">bound_upd</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">get_output_extents</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">low_ind</span><span class="p">,</span> <span class="n">high_ind</span><span class="p">);</span>

          <span class="c1">// Because we overlapped the grid the range may extend outside of the</span>
          <span class="c1">// field arrays. To fix this, we simply change -1 -&gt; 0 in the indexing</span>
          <span class="c1">// if it occurs.</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">low_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">low_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">low_ind</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

          <span class="c1">// set extents for loops</span>
          <span class="n">nxm</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nx</span><span class="p">;</span>
          <span class="n">nym</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ny</span><span class="p">;</span>

          <span class="c1">// copy in the face values to the Ex faces</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">k</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
                <span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
              <span class="n">E</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">get_new_face_vals</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="c1">// end if crbc</span>
    <span class="p">}</span> <span class="c1">// end for</span>
  <span class="p">}</span> <span class="c1">// end isBoundaryProc</span>

  <span class="c1">// stop timer</span>
  <span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
  <span class="n">step_DAB_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="functions-to-copy-to-and-from-dab-updaters">
<h3>Functions to Copy To and From DAB Updaters<a class="headerlink" href="#functions-to-copy-to-and-from-dab-updaters" title="Permalink to this headline">¶</a></h3>
<p>The following functions are commonly used loops to copy data bewteen send and
receive buffers and the DAB updaters. These differ from where we copy data to
and from the solver and the DAB updater because these get data at all of the
auxiliary recursion levels used in the DAB updaters.</p>
<p>There are two sets on loops in each function, one is for getting data from the
auxiliary variables on a face and the other is for getting auxiliary data from
the edge variables. The difference is that the face data has a single auxiliary
index and the edge data is doubly indexed.</p>
<p>For simplicity, we just add the auxiliary variables to the vector by placing
the data in the next available spot. We do this primarily to avoid having to
do extra indexing that changes depending on the side and component. This means
that we depend on these loops being executed in the same order, so it is not
viable to use threading in this location.</p>
<p>The first function copies data from the updater object to the buffer</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">get_dab_vals_loop</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span>
                       <span class="n">crbc</span><span class="o">::</span><span class="n">CrbcUpdates</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">updater</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">side</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">low</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">high</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">plow</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">phigh</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">isedge</span><span class="p">)</span>
<span class="p">{</span>

  <span class="cm">/* DO NOT THREAD THESE LOOPS</span>
<span class="cm">     We are depending on the order being the same</span>
<span class="cm">  */</span>

  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span> <span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">isedge</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pind</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">plow</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">p</span><span class="o">&lt;=</span><span class="n">phigh</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">plow</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">q</span><span class="o">&lt;=</span><span class="n">phigh</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pind</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">k</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
              <span class="n">buffer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">updater</span><span class="p">.</span><span class="n">get_edge_auxiliary_vars</span><span class="p">(</span><span class="n">side</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">pind</span><span class="p">));</span>
            <span class="p">}</span> <span class="c1">// i</span>
          <span class="p">}</span> <span class="c1">// j</span>
        <span class="p">}</span> <span class="c1">// k</span>
      <span class="p">}</span> <span class="c1">// q</span>
    <span class="p">}</span> <span class="c1">// p</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">plow</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">p</span><span class="o">&lt;=</span><span class="n">phigh</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">k</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">buffer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">updater</span><span class="p">.</span><span class="n">get_auxiliary_vars</span><span class="p">(</span><span class="n">side</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>
          <span class="p">}</span> <span class="c1">// i</span>
        <span class="p">}</span> <span class="c1">// j</span>
      <span class="p">}</span> <span class="c1">// k</span>
    <span class="p">}</span> <span class="c1">// p</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The second function copies data from the buffer to the updater object</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">set_dab_vals_loop</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span>
                       <span class="n">crbc</span><span class="o">::</span><span class="n">CrbcUpdates</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">updater</span><span class="p">,</span>
                       <span class="kt">int</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">side</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">low</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">high</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">plow</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">phigh</span><span class="p">,</span>
                       <span class="k">const</span> <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">isedge</span><span class="p">)</span>
<span class="p">{</span>

  <span class="cm">/* DO NOT THREAD THESE LOOPS</span>
<span class="cm">     We are depending on the order being the same</span>
<span class="cm">  */</span>

  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span> <span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">isedge</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pind</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">plow</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">p</span><span class="o">&lt;=</span><span class="n">phigh</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">plow</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">q</span><span class="o">&lt;=</span><span class="n">phigh</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pind</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">k</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
              <span class="n">updater</span><span class="p">.</span><span class="n">set_edge_auxiliary_vars</span><span class="p">(</span><span class="n">side</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">pind</span><span class="p">,</span> <span class="n">buffer</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]);</span>
            <span class="p">}</span> <span class="c1">// i</span>
          <span class="p">}</span> <span class="c1">// j</span>
        <span class="p">}</span> <span class="c1">// k</span>
      <span class="p">}</span> <span class="c1">// q</span>
    <span class="p">}</span> <span class="c1">// p</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="n">plow</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">p</span><span class="o">&lt;=</span><span class="n">phigh</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">k</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">updater</span><span class="p">.</span><span class="n">set_auxiliary_vars</span><span class="p">(</span><span class="n">side</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">buffer</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]);</span>
          <span class="p">}</span> <span class="c1">// i</span>
        <span class="p">}</span> <span class="c1">// j</span>
      <span class="p">}</span> <span class="c1">// k</span>
    <span class="p">}</span> <span class="c1">// p</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-identify-how-to-send-dab-auxiliary-variables">
<h3>Function to Identify How to send DAB Auxiliary Variables<a class="headerlink" href="#function-to-identify-how-to-send-dab-auxiliary-variables" title="Permalink to this headline">¶</a></h3>
<p>This function idientifies the directions and processor IDs
that the current process needs to communicate DAB information.</p>
<p>Note this only checks the cases possible in this implementation. A more
generic implementation would need to handle more cases. In particular, we
can’t have 2 parallel faces that need to pass data from the same process since
we are assuming each direction has the same number of processes and we do
not need to pass any information if we only have 1 process.</p>
<p>We start by figuring out the possible directions we need to sent. We do this by
looping over all of the sides on the current process. If we find a side with the
boundary type of <code class="docutils literal notranslate"><span class="pre">CRBC</span></code>, we then need to check to see if the neighboring sides have
a boundary type <code class="docutils literal notranslate"><span class="pre">NONE</span></code>. We any sides that satisfy this check to a list.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">calc_DAB_send_params</span><span class="p">()</span>
<span class="p">{</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">tang_sides</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">diag_coords</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">diag_rank</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">corner_pairs</span><span class="p">;</span>

  <span class="c1">// first identify the directions that we need to send</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// loop over sides</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// loop over sides</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span> <span class="o">==</span> <span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
          <span class="k">continue</span><span class="p">;</span> <span class="c1">// skip parallel sides</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span>
          <span class="n">send_dirs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>Next, it is possible that our list of direction we need to send has duplicates.
This can occur if there process is at the edge or corner of the domain. We simply
remove any duplicates using Standard Template Library Functions that are available
in C++11.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// remove any duplicates in send_dirs</span>
<span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">send_dirs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">send_dirs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="k">auto</span> <span class="n">last</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique</span><span class="p">(</span><span class="n">send_dirs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">send_dirs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="n">send_dirs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">send_dirs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></div>
</div>
<p>After we have a list of all of the directoins that we need to send
data in, we create a list of all of the adjacent sides.
(It is possible to do this with clever indexing, but it is much clearer to just
use a case statement).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// loop over the send directions</span>
<span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">send_dirs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// figure out which sides need to send in the current direction</span>
  <span class="c1">// start by listing the tangential sides</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">send_dirs</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="c1">// outward normal is +/-x</span>
      <span class="n">tang_sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// left y</span>
      <span class="n">tang_sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// right y</span>
      <span class="n">tang_sides</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// left z</span>
      <span class="n">tang_sides</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// right z</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="c1">// outward normal is +/-y</span>
      <span class="n">tang_sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// left x</span>
      <span class="n">tang_sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// right x</span>
      <span class="n">tang_sides</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// left z</span>
      <span class="n">tang_sides</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// right z</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="c1">// outward normal is +/-z</span>
      <span class="n">tang_sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// left x</span>
      <span class="n">tang_sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// right x</span>
      <span class="n">tang_sides</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// left y</span>
      <span class="n">tang_sides</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// left z</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span> <span class="c1">// shouldn&#39;t happen</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span>
        <span class="n">tang_sides</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;invalid side&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>For each of the sides tangent to the send directions that are a DAB/CRBC boundary,
we save the side to a list. Then we convert the local side index to the MPI rank
of the neighboring process in the appropriate direction.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// check to see if any of the tangetial sides are a DAB/CRBC boundary</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="n">tang_sides</span><span class="p">[</span><span class="n">m</span><span class="p">]]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">send_sides</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">tang_sides</span><span class="p">[</span><span class="n">m</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// finally change the directions from local side indices to the MPI ranks in</span>
<span class="c1">// the appropriate direction</span>
<span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">send_dirs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">send_mpi_dirs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">MPI_DIR</span><span class="p">[</span><span class="n">send_dirs</span><span class="p">[</span><span class="n">l</span><span class="p">]]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After we have dealt with the sides, we deal with any situations where we might
need to send data diagonally. In particular, recall that we overlapped the grid
by 2 points, so we have a data configuration that looks like</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>     <span class="o">|</span>   <span class="o">|</span>
  <span class="n">o</span>  <span class="n">o</span>   <span class="n">o</span>  <span class="n">o</span>      <span class="n">Here</span><span class="p">,</span> <span class="n">the</span> <span class="n">process</span> <span class="n">boundaries</span> <span class="n">are</span> <span class="n">represented</span>
     <span class="o">|</span>   <span class="o">|</span>         <span class="n">by</span> <span class="o">--</span> <span class="n">or</span> <span class="o">|</span><span class="p">.</span> <span class="n">Grid</span> <span class="n">points</span> <span class="n">are</span> <span class="n">represented</span> <span class="n">by</span> <span class="n">o</span><span class="p">,</span> <span class="n">x</span>
<span class="o">--</span><span class="n">x</span><span class="o">--</span><span class="n">o</span>   <span class="n">x</span><span class="o">--</span><span class="n">o</span><span class="o">--</span>

<span class="o">--</span><span class="n">o</span><span class="o">--</span><span class="n">o</span>   <span class="n">o</span><span class="o">--</span><span class="n">o</span><span class="o">--</span>
     <span class="o">|</span>   <span class="o">|</span>
  <span class="n">x</span>  <span class="n">o</span>   <span class="n">x</span>  <span class="n">o</span>
     <span class="o">|</span>   <span class="o">|</span>
</pre></div>
</div>
<p>Where the grid point <code class="docutils literal notranslate"><span class="pre">x</span></code> has the same physical coordinates but is located at
different positions on each of the four processes. We note that the DAB uses the
7-point wave stencil, so the DAB updater is not able to update any of the points
on the process boundaries. However, due to the overlap, we see that we can get
these values from a neighboring process.</p>
<p>We’re ordering the possible corners in a standard way because this makes it
easier to keep track of things when we’re actually doing the message
passing. The ordering we are using is</p>
<ol class="arabic simple" start="0">
<li><p>CRBC side = 0 or 1 (x normal), tang. sides 2, 4 (South and Down)</p></li>
<li><p>CRBC side = 0 or 1 (x normal), tang. sides 2, 5 (South and Up)</p></li>
<li><p>CRBC side = 0 or 1 (x normal), tang. sides 3, 4 (North and Down)</p></li>
<li><p>CRBC side = 0 or 1 (x normal), tang. sides 3, 5 (North and Up)</p></li>
<li><p>CRBC side = 2 or 3 (y normal), tang. sides 0, 4 (West and Down)</p></li>
<li><p>CRBC side = 2 or 3 (y normal), tang. sides 0, 5 (West and Up)</p></li>
<li><p>CRBC side = 2 or 3 (y normal), tang. sides 1, 4 (East and Down)</p></li>
<li><p>CRBC side = 2 or 3 (y normal), tang. sides 1, 5 (East and Up)</p></li>
<li><p>CRBC side = 4 or 5 (z normal), tang. sides 0, 2 (West and South)</p></li>
<li><p>CRBC side = 4 or 5 (z normal), tang. sides 0, 3 (West and North)</p></li>
<li><p>CRBC side = 4 or 5 (z normal), tang. sides 1, 2 (East and South)</p></li>
<li><p>CRBC side = 4 or 5 (z normal), tang. sides 1, 3 (East and North)</p></li>
</ol>
<p>Again, note that this does not cover all the cases for a generic implementation
because we can not, e.g., have 2 parallel CRBC sides on the same process
in the current configuration.</p>
<p>The following code does essentially the same as above, but this time it checks
for 2 perpendicular faces with boudnary type <code class="docutils literal notranslate"><span class="pre">CRBC</span></code> that have a common neighbor
with the boundary type <code class="docutils literal notranslate"><span class="pre">NONE</span></code>. It then figures out the neighbor diagonal to this
edge and saves the MPI rank of that neighbor.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Start by checking for perpindicular sends from the same side</span>
<span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// loop over sides</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>

      <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="c1">// outward normal is +/-x</span>
        <span class="n">tang_sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// left y</span>
        <span class="n">tang_sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// right y</span>
        <span class="n">tang_sides</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// left z</span>
        <span class="n">tang_sides</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// right z</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="c1">// outward normal is +/-y</span>
        <span class="n">tang_sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// left x</span>
        <span class="n">tang_sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// right x</span>
        <span class="n">tang_sides</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// left z</span>
        <span class="n">tang_sides</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// right z</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="c1">// outward normal is +/-z</span>
        <span class="n">tang_sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// left x</span>
        <span class="n">tang_sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// right x</span>
        <span class="n">tang_sides</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// left y</span>
        <span class="n">tang_sides</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// left z</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">default</span><span class="o">:</span> <span class="c1">// shouldn&#39;t happen</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span>
          <span class="n">tang_sides</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;invalid side&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// loop tangential sides</span>

      <span class="c1">// this checks the pairs (0,2), (0,3), (1,2), (1,3) of tangential sides</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">procBounds</span><span class="p">[</span><span class="n">tang_sides</span><span class="p">[</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">]]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
          <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="n">tang_sides</span><span class="p">[</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">m</span><span class="o">%</span><span class="mi">2</span><span class="p">)]]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">))</span> <span class="p">{</span>

        <span class="n">corner_pairs</span> <span class="o">=</span> <span class="p">{</span><span class="n">tang_sides</span><span class="p">[</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="n">tang_sides</span><span class="p">[</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">m</span><span class="o">%</span><span class="mi">2</span><span class="p">)]};</span>
        <span class="n">send_corners</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">int</span><span class="p">)</span> <span class="n">l</span><span class="p">,</span> <span class="n">tang_sides</span><span class="p">[</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="n">tang_sides</span><span class="p">[</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">m</span><span class="o">%</span><span class="mi">2</span><span class="p">)]};</span>

        <span class="c1">// now figure out the mpi rank of the destination</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
          <span class="n">diag_coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cart_rank</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="c1">// figure out the destination coords by adding +-1 to the coordinates</span>
        <span class="c1">// of the current process in the appropriate dimensions</span>
        <span class="n">diag_coords</span><span class="p">[</span><span class="n">corner_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">corner_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> \
          <span class="n">diag_coords</span><span class="p">[</span><span class="n">corner_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">diag_coords</span><span class="p">[</span><span class="n">corner_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">diag_coords</span><span class="p">[</span><span class="n">corner_pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">corner_pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> \
          <span class="n">diag_coords</span><span class="p">[</span><span class="n">corner_pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">diag_coords</span><span class="p">[</span><span class="n">corner_pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Cart_rank</span><span class="p">(</span><span class="n">grid_comm</span><span class="p">,</span> <span class="n">diag_coords</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">diag_rank</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
          <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Cart_rank failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="c1">// save rank</span>
        <span class="n">corner_mpi_dirs</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">diag_rank</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-send-dab-values">
<h3>Function to send DAB Values<a class="headerlink" href="#function-to-send-dab-values" title="Permalink to this headline">¶</a></h3>
<p>This function is responsible for sending the DAB auxiliary variables to neighboring
processes when needed. The most important thing to remember here is that the DAB
layer is only 3-points wide in the normal direction to the boundary. The only
updates that the DAB layer does that require message passing are 7-point wave
equation stencil updates and these updates are only used on the middle layer of
points in the DAB. Therefore, we only need to send the DAB values in this middle
layer (these points correspond to the auxiliary variables that are located at the
output location of the DAB).</p>
<p>The idea is on each process, we will loop over all of the directions we need to
send data in.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">send_DAB</span><span class="p">()</span>
<span class="p">{</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">sidea</span><span class="p">,</span> <span class="n">sideb</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">edge</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">low</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">high</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">plow</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">phigh</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>

  <span class="c1">// start timer</span>
  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">isBoundaryProc</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// loop over the directions we need to send</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">send_dirs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>Next, we delete any data left over from the previous time step in the send and
receive buffers for the current side. Then we loop over all of the boundary sides
that need to send data in the current direction and also loop over all three
boundary updater components.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">side</span> <span class="o">=</span> <span class="n">send_dirs</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>

<span class="c1">// clear the buffers for this direction</span>
<span class="n">DAB_sbuf</span><span class="p">[</span><span class="n">side</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
<span class="n">DAB_rbuf</span><span class="p">[</span><span class="n">side</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>

<span class="c1">// loop over the sides we need to send in the current direction</span>
<span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="n">send_sides</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// loop over the components</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">sidea</span> <span class="o">=</span> <span class="n">send_sides</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">at</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
</pre></div>
</div>
<p>Then, we get the spatial indexing for the middle layer of auxiliary variables
by asking the DAB updater objects for the output extents.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// get data extents for current component</span>
<span class="c1">// This gets us the indices for all the points on the plane</span>
<span class="c1">// parallel to the phyiscal boundary</span>
<span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_output_extents</span><span class="p">(</span><span class="n">sidea</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
</pre></div>
</div>
<p>The ouput extents covers the entire plane of points parallel to the DAB boundary, but
we only need to send the second to last line of points parallel to the neigboring process
where we are sending the data. We can get the component of the indices we need to
change using <code class="docutils literal notranslate"><span class="pre">side</span> <span class="pre">/</span> <span class="pre">2</span></code> (here 0 corresponds to sending in the x-direction, 1
corresponds to sending the y-direction, and 2 corresponds to sending in the z-direction).
Then we can determine if we are sending “right” or “left” by using <code class="docutils literal notranslate"><span class="pre">side</span> <span class="pre">%</span> <span class="pre">2</span></code>.
We use this information to modify the data extents: if we send left, we add 1 to
the low extent to start at the 2nd line of points and set the high extent to this
new low extent so we stop after this line. Similarly, if we send right, we subtract
1 from the high extent to finish at the 2nd last line of points and set the low extent
to this new high extent so we also start at the 2nd to last line of points.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// now we need to restrict to second to last line of points parallel to</span>
<span class="c1">// the boundary we are sending. side / 2 gives us the component of the</span>
<span class="c1">// extents we need to modify and side % 2 tells us if we need to modify</span>
<span class="c1">// the low or high extents. Here, we also adjust for the overlap</span>
<span class="c1">// based on the component</span>
<span class="k">if</span> <span class="p">(</span><span class="n">side</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left side in the appropriate direction</span>
  <span class="n">high</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">?</span> <span class="o">++</span><span class="n">low</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">:</span> <span class="o">++</span><span class="n">low</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// right side in the appropriate direction</span>
  <span class="n">low</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">?</span> <span class="o">--</span><span class="n">high</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">:</span> <span class="o">--</span><span class="n">high</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, we copy the DAB auxiliary variables into the send buffer</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>    <span class="c1">// copy data auxilliary data into the send buffer</span>
    <span class="n">plow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// auxilliary index bounds</span>
    <span class="n">phigh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_num_recursions</span><span class="p">(</span><span class="n">sidea</span><span class="p">);</span>
    <span class="n">get_dab_vals_loop</span><span class="p">(</span><span class="n">DAB_sbuf</span><span class="p">[</span><span class="n">side</span><span class="p">],</span> <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sidea</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">plow</span><span class="p">,</span> <span class="n">phigh</span><span class="p">);</span>

  <span class="p">}</span> <span class="c1">// loop over components</span>

<span class="p">}</span> <span class="c1">// end loop over sides in the current direction</span>
</pre></div>
</div>
<p>Next we do the exact same thing for any edges that we need to send. The only
difference here is the boundary updater now returns a line of points when we
ask for the output extents and we need to restrict this list to the 2nd to last
point on the line. We do this in the same way that we restricted the plane to a
line for the face data above and then we copy the auxiliary values into the
send buffer.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// now send any edge data</span>
<span class="k">if</span> <span class="p">(</span><span class="n">send_sides</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// loop over the components</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// get edge index</span>
    <span class="n">edge</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_edge_index</span><span class="p">(</span><span class="n">send_sides</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">send_sides</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>

    <span class="c1">// get edge data extents</span>
    <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_edge_extents</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">plow</span><span class="p">,</span> <span class="n">phigh</span><span class="p">);</span>

    <span class="c1">// now we need to restrict to second to last point parallel to</span>
    <span class="c1">// the boundaries we are sending. side / 2 gives us the component of the</span>
    <span class="c1">// extents we need to modify and side % 2 tells us if we need to modify</span>
    <span class="c1">// the low or high extents</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">side</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left side in the appropriate direction</span>
      <span class="n">high</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">?</span>  <span class="o">++</span><span class="n">low</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">:</span> <span class="o">++</span><span class="n">low</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// right side in the appropriate direction</span>
      <span class="n">low</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="o">?</span>  <span class="o">--</span><span class="n">high</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">:</span> <span class="o">--</span><span class="n">high</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// the true at the end tells the function plow, phigh are arrays of len 2</span>
    <span class="n">get_dab_vals_loop</span><span class="p">(</span><span class="n">DAB_sbuf</span><span class="p">[</span><span class="n">side</span><span class="p">],</span> <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">edge</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">plow</span><span class="p">,</span> <span class="n">phigh</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

  <span class="p">}</span> <span class="c1">// end loop over components</span>

<span class="p">}</span> <span class="c1">// end if 2 sides</span>
</pre></div>
</div>
<p>Finally, we actually send the data. We use non-blocking sends in the hope that
the time it takes to compute the H-field updates will mask most or all
of the communication. All of the sends and receives happen in pairs, so if process
1 sends data to process 2, process 1 should also recieve data from process 2.
We use a tag of <code class="docutils literal notranslate"><span class="pre">1</span></code> to indicate that this is a DAB send.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// create and save requests</span>
  <span class="n">MPI_Request</span> <span class="n">sreq</span><span class="p">,</span> <span class="n">rreq</span><span class="p">;</span>

  <span class="n">DAB_send_req</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sreq</span><span class="p">);</span>
  <span class="n">DAB_recv_req</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">rreq</span><span class="p">);</span>

  <span class="c1">// Send --- we use a tag of 1 for DAB send and 0 for E-field sends</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Isend</span><span class="p">(</span><span class="n">DAB_sbuf</span><span class="p">[</span><span class="n">side</span><span class="p">].</span><span class="n">data</span><span class="p">(),</span> <span class="n">DAB_sbuf</span><span class="p">[</span><span class="n">side</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> \
      <span class="n">send_mpi_dirs</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">grid_comm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DAB_send_req</span><span class="p">.</span><span class="n">back</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Isend failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// make sure the recieve buffer is large enough</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">DAB_rbuf</span><span class="p">[</span><span class="n">side</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">DAB_sbuf</span><span class="p">[</span><span class="n">side</span><span class="p">].</span><span class="n">size</span><span class="p">())</span>
    <span class="n">DAB_rbuf</span><span class="p">[</span><span class="n">side</span><span class="p">].</span><span class="n">assign</span><span class="p">(</span><span class="n">DAB_sbuf</span><span class="p">[</span><span class="n">side</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="mf">0.0</span><span class="p">);</span>

  <span class="c1">// Recieve</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Irecv</span><span class="p">(</span><span class="n">DAB_rbuf</span><span class="p">[</span><span class="n">side</span><span class="p">].</span><span class="n">data</span><span class="p">(),</span> <span class="n">DAB_rbuf</span><span class="p">[</span><span class="n">side</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span>
      <span class="n">send_mpi_dirs</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">grid_comm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DAB_recv_req</span><span class="p">.</span><span class="n">back</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Isend failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// end loop over send directions</span>
</pre></div>
</div>
<p>Next we deal with any diagonal sends we might have. This works very similarly to
the above, but this time a given DAB face will get 2 directions to send, which
corresponds to sending diagonally (e.g. up and to the left). As before, we get
the output extents from the boundary updater and need to restrict this plane to
the 2nd to last line of points parallel to <code class="docutils literal notranslate"><span class="pre">sidea</span></code> and then we need to further
restrict this line of points to the 2nd to last point to <code class="docutils literal notranslate"><span class="pre">sideb</span></code>. Again, we
do this in the same way as before, we just do it once for <code class="docutils literal notranslate"><span class="pre">sidea</span></code> and once for
<code class="docutils literal notranslate"><span class="pre">sideb</span></code>. Then we copy the auxiliary variables into the corner DAB send buffer
and set up non-blocking sends and receives as before.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Finally send anything diagonally that we need to</span>
  <span class="c1">// loop over the sides</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// loop over directions we need to send on the current side</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="n">corner_mpi_dirs</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// this should either be 1 or 0</span>

      <span class="c1">// clear the buffers for this direction</span>
      <span class="n">DAB_corner_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
      <span class="n">DAB_corner_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>

      <span class="c1">// loop over the components</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// get the two send directions and the CRBC face</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">send_corners</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// crbc/dab face</span>
        <span class="n">sidea</span> <span class="o">=</span> <span class="n">send_corners</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// send direction 1</span>
        <span class="n">sideb</span> <span class="o">=</span> <span class="n">send_corners</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// send direction 2</span>

        <span class="c1">// get data extents for current component</span>
        <span class="c1">// This gets us the indices for all the points on the plane</span>
        <span class="c1">// parallel to the phyiscal boundary</span>
        <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_output_extents</span><span class="p">(</span><span class="n">side</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>

        <span class="c1">// now we need to restrict to second to last line of points parallel to</span>
        <span class="c1">// the boundary we are sending. side / 2 gives us the component of the</span>
        <span class="c1">// extents we need to modify and side % 2 tells us if we need to modify</span>
        <span class="c1">// the low or high extents. Here, we also adjust for the overlap</span>
        <span class="c1">// based on the component</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sidea</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left side in the appropriate direction</span>
          <span class="n">high</span><span class="p">[</span><span class="n">sidea</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">low</span><span class="p">[</span><span class="n">sidea</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// right side in the appropriate direction</span>
          <span class="n">low</span><span class="p">[</span><span class="n">sidea</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">--</span><span class="n">high</span><span class="p">[</span><span class="n">sidea</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sideb</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left side in the appropriate direction</span>
          <span class="n">high</span><span class="p">[</span><span class="n">sideb</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="n">low</span><span class="p">[</span><span class="n">sideb</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// right side in the appropriate direction</span>
          <span class="n">low</span><span class="p">[</span><span class="n">sideb</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">--</span><span class="n">high</span><span class="p">[</span><span class="n">sideb</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="c1">// copy data auxilliary data into the send buffer</span>
        <span class="n">plow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// auxilliary index bounds</span>
        <span class="n">phigh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_num_recursions</span><span class="p">(</span><span class="n">side</span><span class="p">);</span>
        <span class="n">get_dab_vals_loop</span><span class="p">(</span><span class="n">DAB_corner_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">side</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">plow</span><span class="p">,</span> <span class="n">phigh</span><span class="p">);</span>

      <span class="p">}</span> <span class="c1">// loop over components</span>

      <span class="c1">// now actually send the data.</span>

      <span class="c1">// create and save requests</span>
      <span class="n">MPI_Request</span> <span class="n">sreq</span><span class="p">,</span> <span class="n">rreq</span><span class="p">;</span>

      <span class="n">DAB_send_req</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sreq</span><span class="p">);</span>
      <span class="n">DAB_recv_req</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">rreq</span><span class="p">);</span>

      <span class="c1">// Send --- we use a tag of 1 for DAB send and 0 for E-field sends</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Isend</span><span class="p">(</span><span class="n">DAB_corner_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">data</span><span class="p">(),</span> <span class="n">DAB_corner_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> \
          <span class="n">corner_mpi_dirs</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">m</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">grid_comm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DAB_send_req</span><span class="p">.</span><span class="n">back</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
              <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Isend failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

      <span class="c1">// make sure the recieve buffer is large enough</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">DAB_corner_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">DAB_corner_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">())</span>
        <span class="n">DAB_corner_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">assign</span><span class="p">(</span><span class="n">DAB_corner_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="mf">0.0</span><span class="p">);</span>

      <span class="c1">// Recieve</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Irecv</span><span class="p">(</span><span class="n">DAB_corner_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">data</span><span class="p">(),</span> <span class="n">DAB_corner_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span>
          <span class="n">corner_mpi_dirs</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">m</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">grid_comm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DAB_recv_req</span><span class="p">.</span><span class="n">back</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
              <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Isend failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="p">}</span> <span class="c1">// end loop over directions we need to send on the current side</span>
  <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end if boundary proc</span>

<span class="c1">// stop timer</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
<span class="n">send_DAB_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-receive-dab-values">
<h3>Function to Receive DAB Values<a class="headerlink" href="#function-to-receive-dab-values" title="Permalink to this headline">¶</a></h3>
<p>This function is the counterpart to <code class="docutils literal notranslate"><span class="pre">send_DAB()</span></code> and is responsible copying the
received values into the DAB auxiliary variable structures. The process is almost
identical, but the main difference is that we send the second to last point(s) and
we want to copy this values into the last row of points. We start by making sure
that the sends have completed.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">recv_DAB</span><span class="p">()</span>
<span class="p">{</span>

  <span class="c1">// note the recieve directions are the same as the send directions, so we do</span>
  <span class="c1">// almost exactly the same thing here as in send_DAB() except we copy from the</span>
  <span class="c1">// buffers to the DAB.</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">sidea</span><span class="p">,</span> <span class="n">sideb</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">low</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">high</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">plow</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">phigh</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>

  <span class="c1">// start timer</span>
  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

  <span class="c1">// make sure all of the recieves are complete before we use the data</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Waitall</span><span class="p">(</span><span class="n">DAB_recv_req</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">DAB_recv_req</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">MPI_STATUSES_IGNORE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Waitall failed (DAB_recv_req)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">DAB_recv_req</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</pre></div>
</div>
<p>Then we start by looping over the sides in exactly the same way as we did in the
send routine. It is very important that we do this in the same order because we
added the data to the buffers using <code class="docutils literal notranslate"><span class="pre">push_back</span></code> and not by using an indexing
convention so we must read the data back in the same order to get the correct
results.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// copy the values from the buffers</span>

<span class="k">if</span> <span class="p">(</span><span class="n">isBoundaryProc</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// loop over the directions we need to send</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">send_dirs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// used for indexing</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">side</span> <span class="o">=</span> <span class="n">send_dirs</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>

    <span class="c1">// loop over the sides we need to send in the current direction</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="n">send_sides</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// loop over components</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">sidea</span> <span class="o">=</span> <span class="n">send_sides</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">at</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>

        <span class="c1">// This gets us the indices for all the points on the plane</span>
        <span class="c1">// parallel to the phyiscal boundary</span>
        <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_output_extents</span><span class="p">(</span><span class="n">sidea</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>
</pre></div>
</div>
<p>Now, if we are receiving from the left we set high index extent to the low index extent to get the
leftmost set of points in the appropriate component. Similary coming from the right
we set the low index extent to the high index extent to get the rightmost set of
points. Then we copy the auxiliary variables from the receive buffer into the DAB
updater object.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>    <span class="c1">// now we need to restrict to  last line of points parallel to</span>
    <span class="c1">// the boundary we are sending. side / 2 gives us the component of the</span>
    <span class="c1">// extents we need to modify and side % 2 tells us if we need to modify</span>
    <span class="c1">// the low or high extents</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">side</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left side in the appropriate direction</span>
      <span class="n">high</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// right side in the appropriate direction</span>
      <span class="n">low</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">high</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// copy data auxilliary data into the send buffer</span>
    <span class="n">plow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// auxilliary index bounds</span>
    <span class="n">phigh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_num_recursions</span><span class="p">(</span><span class="n">sidea</span><span class="p">);</span>
    <span class="n">set_dab_vals_loop</span><span class="p">(</span><span class="n">DAB_rbuf</span><span class="p">[</span><span class="n">side</span><span class="p">],</span> <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">count</span><span class="p">,</span> <span class="n">sidea</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">plow</span><span class="p">,</span> <span class="n">phigh</span><span class="p">);</span>

  <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end loop over sides in the current direction</span>
</pre></div>
</div>
<p>Next, we do the edges in the same manner.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// now receive any edge data</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">send_sides</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// loop over components</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// get edge index</span>
      <span class="n">edge</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_edge_index</span><span class="p">(</span><span class="n">send_sides</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">send_sides</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
      <span class="c1">// get edge data extents</span>
      <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_edge_extents</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">plow</span><span class="p">,</span> <span class="n">phigh</span><span class="p">);</span>

      <span class="c1">// now we need to restrict to last point parallel to</span>
      <span class="c1">// the boundaries we are sending. side / 2 gives us the component of the</span>
      <span class="c1">// extents we need to modify and side % 2 tells us if we need to modify</span>
      <span class="c1">// the low or high extents</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">side</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left side in the appropriate direction</span>
        <span class="n">high</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// right side in the appropriate direction</span>
        <span class="n">low</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">high</span><span class="p">[</span><span class="n">side</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
      <span class="p">}</span>

      <span class="c1">// the true at the end tells the function plow, phigh are arrays of len 2</span>
      <span class="n">set_dab_vals_loop</span><span class="p">(</span><span class="n">DAB_rbuf</span><span class="p">[</span><span class="n">side</span><span class="p">],</span> <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">count</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">plow</span><span class="p">,</span> <span class="n">phigh</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

    <span class="p">}</span>

  <span class="p">}</span> <span class="c1">// end if 2 sides</span>

<span class="p">}</span> <span class="c1">// end loop over send directions</span>
</pre></div>
</div>
<p>Finally, we follow the same procedure to copy any diagonaly sent data into the
DAB updaters.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Finally get anything diagonally that we need</span>
  <span class="c1">// loop over the sides</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// loop over directions we need to send on the current side</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="n">corner_mpi_dirs</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// used for indexing</span>
      <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

      <span class="c1">// loop over the components</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// get the two send directions and the CRBC face</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">send_corners</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// crbc/dab face</span>
        <span class="n">sidea</span> <span class="o">=</span> <span class="n">send_corners</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span> <span class="c1">// send direction 1</span>
        <span class="n">sideb</span> <span class="o">=</span> <span class="n">send_corners</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// send direction 2</span>

        <span class="c1">// get data extents for current component</span>
        <span class="c1">// This gets us the indices for all the points on the plane</span>
        <span class="c1">// parallel to the phyiscal boundary</span>
        <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_output_extents</span><span class="p">(</span><span class="n">side</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">);</span>

        <span class="c1">// now we need to restrict to second to last line of points parallel to</span>
        <span class="c1">// the boundary we are sending. side / 2 gives us the component of the</span>
        <span class="c1">// extents we need to modify and side % 2 tells us if we need to modify</span>
        <span class="c1">// the low or high extents. Here, we also adjust for the overlap</span>
        <span class="c1">// based on the component</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sidea</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left side in the appropriate direction</span>
          <span class="n">high</span><span class="p">[</span><span class="n">sidea</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span><span class="p">[</span><span class="n">sidea</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// right side in the appropriate direction</span>
          <span class="n">low</span><span class="p">[</span><span class="n">sidea</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">high</span><span class="p">[</span><span class="n">sidea</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sideb</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left side in the appropriate direction</span>
          <span class="n">high</span><span class="p">[</span><span class="n">sideb</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span><span class="p">[</span><span class="n">sideb</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// right side in the appropriate direction</span>
          <span class="n">low</span><span class="p">[</span><span class="n">sideb</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">high</span><span class="p">[</span><span class="n">sideb</span> <span class="o">/</span> <span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="c1">// copy data auxilliary data into the send buffer</span>
        <span class="n">plow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// auxilliary index bounds</span>
        <span class="n">phigh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_num_recursions</span><span class="p">(</span><span class="n">side</span><span class="p">);</span>
        <span class="n">set_dab_vals_loop</span><span class="p">(</span><span class="n">DAB_corner_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">bound_upd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">count</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">plow</span><span class="p">,</span> <span class="n">phigh</span><span class="p">);</span>

      <span class="p">}</span> <span class="c1">// loop over components</span>

    <span class="p">}</span> <span class="c1">// end loop over directions we need to send on the current side</span>
  <span class="p">}</span>

<span class="p">}</span> <span class="c1">// end if boundary proc</span>
</pre></div>
</div>
<p>Before completing the routine, we make sure all of the data sends have been completed.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// make sure all the sends have completed</span>
<span class="k">if</span> <span class="p">(</span><span class="n">MPI_Waitall</span><span class="p">(</span><span class="n">DAB_send_req</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">DAB_send_req</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">MPI_STATUSES_IGNORE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Waitall failed (DAB_send_req)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="n">DAB_send_req</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

<span class="c1">// stop timer</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
<span class="n">recv_DAB_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-send-e-field-values">
<h3>Function to Send E-Field Values<a class="headerlink" href="#function-to-send-e-field-values" title="Permalink to this headline">¶</a></h3>
<p>This function is responsible for sending the E-field values to neighboring
process that need the updated values. When sending the E-fields, due to the
staggared grid of the Yee scheme, it is only necessary to send the tangential
field components.</p>
<p>Unlike the DAB sends, we do not precompute a list of the required send directions,
so we begin by looping over all of the sides and checking to see if we need to
send any data, which is indicated by a boundary type of <code class="docutils literal notranslate"><span class="pre">NONE</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">send_E</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span> <span class="n">min</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">max</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">data_ext</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">comp</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>

  <span class="c1">// start timer</span>
  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

  <span class="n">min</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nx</span><span class="p">;</span>
  <span class="n">max</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ny</span><span class="p">;</span>
  <span class="n">max</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nz</span><span class="p">;</span>

  <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nx</span><span class="p">;</span>
  <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ny</span><span class="p">;</span>
  <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nz</span><span class="p">;</span>

  <span class="c1">// loop over the the directions we may need to send values</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// clear any old entries</span>
    <span class="n">E_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">E_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>

    <span class="c1">// (re)set the min loop indices</span>
    <span class="n">min</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// check to see if we need to send data in the current direction</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>Next we figure out the loop extents. If we are sending left, we need the second
plane of points from the “left” boundary so we set the min index to 1 and the max
index to 2 in the appropriate component. Similary, if we send right, we need
the second to last plane of points so we set the min index to the max minus 2
and subtract 1 from the max.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// figure out the loop indices.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left side set index in normal direction to 1</span>
  <span class="n">min</span><span class="p">[</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">max</span><span class="p">[</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// (l/2) gives normal component</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// right side set index to n-2</span>
  <span class="n">min</span><span class="p">[</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">max</span><span class="p">[</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// (l/2) gives normal component</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Next we identify a tangential component. The components that are the tangential
to the direction to <code class="docutils literal notranslate"><span class="pre">l/2</span></code> can be computed by <code class="docutils literal notranslate"><span class="pre">((l/2)</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">%</span> <span class="pre">3)</span></code> and <code class="docutils literal notranslate"><span class="pre">((l/2)</span> <span class="pre">+</span> <span class="pre">2)</span> <span class="pre">%</span> <span class="pre">3)</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">comp</span> <span class="o">=</span> <span class="p">((</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span>
</pre></div>
</div>
<p>Next, we figure out the indices for the current component. They should be
0:n in the direction tangent to <code class="docutils literal notranslate"><span class="pre">l/2`</span> <span class="pre">and</span> <span class="pre">``comp</span></code> and 0:n-1 for the direction
normal to <code class="docutils literal notranslate"><span class="pre">comp</span></code>. Note the <code class="docutils literal notranslate"><span class="pre">max``and</span> <span class="pre">``min</span></code> indexing extents correspond to the
field values and the <code class="docutils literal notranslate"><span class="pre">data_ext</span></code> correspond to the data strides in the <code class="docutils literal notranslate"><span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">y</span></code> dimenstions.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">max</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">data_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nx</span><span class="p">;</span>
<span class="n">data_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ny</span><span class="p">;</span>

<span class="c1">// for the tangential component, the possible pairs of (l/2) and comp are</span>
<span class="c1">// (0,1) (0,2) or (1,2), up to ordering</span>
<span class="c1">// We want to map (0,1) -&gt; 2, (0,2) -&gt; 1, and (1,2) -&gt; 0 and we can do that</span>
<span class="c1">// with the following formula:</span>
<span class="c1">// (2*((l/2) + comp) % 3)</span>
<span class="n">max</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">comp</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">comp</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">];</span>

<span class="c1">// now copy the current component into the buffer</span>
<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="n">E_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">comp</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">data_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">data_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]]);</span>
</pre></div>
</div>
<p>After copying the values into the send buffer, we do exactly the same thing for
the second tangential component.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// now do the other possible component</span>
<span class="n">comp</span> <span class="o">=</span> <span class="p">((</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span>

<span class="c1">// figure out indices for the current component. T</span>
<span class="n">max</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">data_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nx</span><span class="p">;</span>
<span class="n">data_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ny</span><span class="p">;</span>
<span class="n">max</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">comp</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">comp</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">];</span>

<span class="c1">// now copy the current component into the buffer</span>
<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="n">E_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">comp</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">data_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">data_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]]);</span>
</pre></div>
</div>
<p>Finally, we send the data using non-blocking MPI routines.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>    <span class="c1">// finally, send the data</span>
    <span class="n">MPI_Request</span> <span class="n">sreq</span><span class="p">,</span> <span class="n">rreq</span><span class="p">;</span>

    <span class="n">send_req</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sreq</span><span class="p">);</span>
    <span class="n">recv_req</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">rreq</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Isend</span><span class="p">(</span><span class="n">E_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">data</span><span class="p">(),</span> <span class="n">E_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="n">MPI_DIR</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">grid_comm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_req</span><span class="p">.</span><span class="n">back</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Isend failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// make sure the receive buffer is big enough</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">E_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">E_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">())</span>
      <span class="n">E_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">assign</span><span class="p">(</span><span class="n">E_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="mf">0.0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Irecv</span><span class="p">(</span><span class="n">E_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">data</span><span class="p">(),</span> <span class="n">E_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="n">MPI_DIR</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">grid_comm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv_req</span><span class="p">.</span><span class="n">back</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Isend failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="p">}</span> <span class="c1">// end if boundary type == none</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Next, we handle any diagonal sends that need to occur. The idea is the same as
above but this time we only need to send that component that is tangent to
the two send directions. For example, if the send is up (in the y-direction) and
to the left (in the x-direction) we need to send the Ez component. We start by
looping over the possible diagonal directions.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// now do any diagonal sends</span>
<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">MPI_EDGE_DIR</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// clear any old entries</span>
  <span class="n">E_edge_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">E_edge_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
</pre></div>
</div>
<p>We figure out which component we need to send. It will be the component
that is tangent to both send directions. For example, if there are
sends in the x and y directions, we need to send the Ez (E[2) component
We get this with <code class="docutils literal notranslate"><span class="pre">(2*((send_edges[l][0]/2)</span> <span class="pre">+</span> <span class="pre">(send_edges[l][1]/2))</span> <span class="pre">%</span> <span class="pre">3)</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">comp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="o">%</span> <span class="mi">3</span><span class="p">);</span>
</pre></div>
</div>
<p>Next, we adjust in the indexing as before, but this time we do it twice for each
of the send directions.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// now figure out the loop extents. This is the same as the sides, but we</span>
<span class="c1">// need to adjust for shifts in two directions instead of 1.</span>
<span class="n">min</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left side set index in normal direction to 1</span>
    <span class="n">min</span><span class="p">[</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">max</span><span class="p">[</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// (l/2) gives normal component</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// right side set index to n-2</span>
    <span class="n">min</span><span class="p">[</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">max</span><span class="p">[</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">max</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">data_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nx</span><span class="p">;</span>
<span class="n">data_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ny</span><span class="p">;</span>
</pre></div>
</div>
<p>Finally, we copy the data into a buffer and use non-blocking messages.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// now copy the current component into the buffer</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">E_edge_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">comp</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">data_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">data_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]]);</span>

  <span class="c1">// finally, send the data</span>
  <span class="n">MPI_Request</span> <span class="n">sreq</span><span class="p">,</span> <span class="n">rreq</span><span class="p">;</span>

  <span class="n">send_req</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sreq</span><span class="p">);</span>
  <span class="n">recv_req</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">rreq</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Isend</span><span class="p">(</span><span class="n">E_edge_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">data</span><span class="p">(),</span> <span class="n">E_edge_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="n">MPI_EDGE_DIR</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">grid_comm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_req</span><span class="p">.</span><span class="n">back</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Isend failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="c1">// make sure the receive buffer is big enough</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">E_edge_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">E_edge_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">())</span>
    <span class="n">E_edge_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">assign</span><span class="p">(</span><span class="n">E_edge_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="mf">0.0</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">MPI_Irecv</span><span class="p">(</span><span class="n">E_edge_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">data</span><span class="p">(),</span> <span class="n">E_edge_sbuf</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">size</span><span class="p">(),</span> <span class="n">MPI_DOUBLE</span><span class="p">,</span> <span class="n">MPI_EDGE_DIR</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">grid_comm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">recv_req</span><span class="p">.</span><span class="n">back</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Isend failed&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="p">}</span>

<span class="c1">// stop timer</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
<span class="n">send_E_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-receive-e-field-values">
<h3>Function to Receive E field Values<a class="headerlink" href="#function-to-receive-e-field-values" title="Permalink to this headline">¶</a></h3>
<p>This function copies the recieved E-field values into the proper place. It does
essentially the same thing as the <code class="docutils literal notranslate"><span class="pre">send_E()</span></code> function but copies data from the
buffers to the boundary data on the appropriate side.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">recv_E</span><span class="p">()</span>
<span class="p">{</span>

  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span> <span class="n">min</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">max</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">n</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">data_ext</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">comp</span><span class="p">,</span> <span class="n">ind</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>

  <span class="c1">// start timer</span>
  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
</pre></div>
</div>
<p>First we wait to make sure all of the receives have been completed.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// make sure all of the receives are complete</span>
<span class="k">if</span> <span class="p">(</span><span class="n">MPI_Waitall</span><span class="p">(</span><span class="n">recv_req</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">recv_req</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">MPI_STATUSES_IGNORE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Waitall failed (recv_req)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="c1">// clear the receive requests</span>
<span class="n">recv_req</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</pre></div>
</div>
<p>Then we loop over all of the sides again as before and check to see if we
expect to receive data on each side. Note that it is important that we check the
sides in the same order as in the send function because that is the order that
the data will be in the receive buffer.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">min</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nx</span><span class="p">;</span>
<span class="n">max</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ny</span><span class="p">;</span>
<span class="n">max</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nz</span><span class="p">;</span>

<span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nx</span><span class="p">;</span>
<span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ny</span><span class="p">;</span>
<span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nz</span><span class="p">;</span>

<span class="c1">// loop over the the directions we may get data</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// (re)set the min loop indices</span>
  <span class="n">min</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// check to see if we need to send data in the current direction</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>As before, we adjust the loop index extents, but this time we select either the
first point if we’re receiving from the left or the last point if we’re receiving
from the right.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// figure out the loop indices.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left side set index in normal direction to 0</span>
  <span class="n">max</span><span class="p">[</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// (l/2) gives normal component</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// right side set index to n-1</span>
  <span class="n">min</span><span class="p">[</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">max</span><span class="p">[</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">];</span>  <span class="c1">// (l/2) gives normal component</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The next section of code is identical to the send case except that we copy the
data into the fields from the buffers.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>    <span class="c1">// the other indices will depend on the E component we are sending</span>
    <span class="c1">// The components are the tangential directions to (l/2) so we can</span>
    <span class="c1">// get these with ((l/2) + 1) % 3) and ((l/2) + 2) % 3).</span>
    <span class="n">comp</span> <span class="o">=</span> <span class="p">((</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span>

    <span class="c1">// figure out indices for the current component. The should be</span>
    <span class="c1">// 0:n in the direction tangent to l/2 and comp and 0:n-1 for the</span>
    <span class="c1">// direction normal to comp</span>
    <span class="n">max</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">data_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nx</span><span class="p">;</span>
    <span class="n">data_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ny</span><span class="p">;</span>

    <span class="c1">// for the tangential component, the possible pairs of (l/2) and comp are</span>
    <span class="c1">// (0,1) (0,2) or (1,2), up to ordering</span>
    <span class="c1">// We want to map (0,1) -&gt; 2, (0,2) -&gt; 1, and (1,2) -&gt; 0 and we can do that</span>
    <span class="c1">// with the following formula:</span>
    <span class="c1">// (2*((l/2) + comp) % 3)</span>
    <span class="n">max</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">comp</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">comp</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">];</span>

    <span class="c1">// now copy the current component into the buffer</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
          <span class="n">E</span><span class="p">[</span><span class="n">comp</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">data_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">data_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">E_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">ind</span><span class="o">++</span><span class="p">];</span>

    <span class="c1">// now do the other possible component</span>
    <span class="n">comp</span> <span class="o">=</span> <span class="p">((</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span>

    <span class="c1">// figure out indices for the current component.</span>
    <span class="n">max</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">data_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nx</span><span class="p">;</span>
    <span class="n">data_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ny</span><span class="p">;</span>
    <span class="n">max</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">comp</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">comp</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">];</span>

    <span class="c1">// now copy the current component into the buffer</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
          <span class="n">E</span><span class="p">[</span><span class="n">comp</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">data_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">data_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">E_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">ind</span><span class="o">++</span><span class="p">];</span>

  <span class="p">}</span> <span class="c1">// end if boundary type == none</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Next we do the same process to copy the diagonal send buffers into the field
values.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// now do any diagonal receives</span>
<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">MPI_EDGE_DIR</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// figure out which component we need to send. It will be the component</span>
  <span class="c1">// that is tangent to both send directions. For example, if there are</span>
  <span class="c1">// sends in the x and y directions, we need to send the Ez (E[2) component</span>
  <span class="c1">// We get this with (2*((send_edges[l][0]/2) + (send_edges[l][1]/2)) % 3)</span>
  <span class="n">comp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span> <span class="o">%</span> <span class="mi">3</span><span class="p">);</span>

  <span class="c1">// now figure out the loop extents. This is the same as the sides, but we</span>
  <span class="c1">// need to adjust for shifts in two directions instead of 1.</span>
  <span class="n">min</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left side set index in normal direction to 0</span>
      <span class="n">max</span><span class="p">[</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// (l/2) gives normal component</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// right side set index to n-1</span>
      <span class="n">min</span><span class="p">[</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">max</span><span class="p">[</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">send_edges</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">max</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">data_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">nx</span><span class="p">;</span>
  <span class="n">data_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">comp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ny</span><span class="p">;</span>

  <span class="c1">// now copy the current component into the buffer</span>
  <span class="n">ind</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">min</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">max</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">E</span><span class="p">[</span><span class="n">comp</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">data_ext</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">data_ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">E_edge_rbuf</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">ind</span><span class="o">++</span><span class="p">];</span>

<span class="p">}</span>
</pre></div>
</div>
<p>Finally, we wait to make sure all of the sends have been completed.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// make sure all the sends have completed</span>
<span class="k">if</span> <span class="p">(</span><span class="n">MPI_Waitall</span><span class="p">(</span><span class="n">send_req</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">send_req</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">MPI_STATUSES_IGNORE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;MPI_Waitall failed (send_req)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="n">send_req</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

<span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
<span class="n">recv_E_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-load-intitial-values">
<h3>Function to Load Intitial Values<a class="headerlink" href="#function-to-load-intitial-values" title="Permalink to this headline">¶</a></h3>
<p>This function simply evaulates the solution routine at the initial time at all
of the grid points. It’s important to remember here that the E-fields and the
H-fields are half a timestep apart so they should be loaded at different locations
in time. Also note that the solution routine has an option to compute the derivatives
(in particular, the curl) with the same finite differences used in the Yee scheme.
It is advantageous to do this because it will result in a numerically divergence
free initial condition.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">load_initial_conds</span><span class="p">()</span> <span class="p">{</span>

  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span> <span class="n">nxm</span><span class="p">,</span> <span class="n">nym</span><span class="p">,</span> <span class="n">nzm</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="n">nxm</span> <span class="o">=</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">nym</span> <span class="o">=</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">nzm</span> <span class="o">=</span> <span class="n">nz</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>
  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

  <span class="c1">// set the solution routine to use the Yee schemes FD operator to compute the</span>
  <span class="c1">// curl in the solution. We do this to get a numerically div free initial</span>
  <span class="c1">// condition</span>
  <span class="n">sol_obj</span><span class="p">.</span><span class="n">set_derivative_method</span><span class="p">(</span><span class="n">maxwell_solutions</span><span class="o">::</span><span class="n">FD_YEE</span><span class="p">);</span>

  <span class="cp">#if USE_OPENMP</span>
  <span class="cp">#pragma omp parallel default(shared) private(i,j,k,x)</span>
  <span class="p">{</span>
  <span class="cp">#endif</span>

    <span class="c1">// load Ex values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nz</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">ny</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nxm</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">k</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">j</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol_obj</span><span class="p">.</span><span class="n">get_Ex_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Etime</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// load Ey values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nz</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nym</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nx</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">k</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
          <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol_obj</span><span class="p">.</span><span class="n">get_Ey_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Etime</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// load Ez values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nzm</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">ny</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nx</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">k</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">j</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
        <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol_obj</span><span class="p">.</span><span class="n">get_Ez_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Etime</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// load Hx values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nzm</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nym</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nx</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">k</span><span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">j</span><span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol_obj</span><span class="p">.</span><span class="n">get_Hx_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Htime</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// load Hy values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nzm</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">ny</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nxm</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">k</span><span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">j</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">i</span><span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol_obj</span><span class="p">.</span><span class="n">get_Hy_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Htime</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// load Hz values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nz</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nym</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nxm</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">k</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">j</span><span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">i</span><span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">=</span> <span class="n">sol_obj</span><span class="p">.</span><span class="n">get_Hz_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Htime</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

  <span class="cp">#if USE_OPENMP</span>
  <span class="p">}</span>
  <span class="cp">#endif</span>

  <span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
  <span class="n">load_init_conds_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-calculate-the-norm">
<h3>Function to Calculate the Norm<a class="headerlink" href="#function-to-calculate-the-norm" title="Permalink to this headline">¶</a></h3>
<p>This function calculates the norm <span class="math notranslate nohighlight">\(\varepsilon \|E\|^2 + \mu \|H\|^2\)</span>.
There are two things to point out here: the first is that the grids are overlapped
so we have to take this into account so we don’t cound some points twice and
second we have a <cite>skip</cite> variable so we can skip points at a regular interval.
Note that the way this is set up, if <cite>skip &gt; 1</cite> then it is possible to get
different norms from the same simulation if using different numbers of processes
because we don’t account for where the last point was sampled on neighboring
processes. This is important if you want to use the norm, but does not have much
effect if the relative norm is computed (or if you divide by the number of points
sampled).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">calc_norm</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">nxm</span><span class="p">,</span> <span class="n">nym</span><span class="p">,</span> <span class="n">nzm</span><span class="p">,</span> <span class="n">is</span><span class="p">,</span> <span class="n">js</span><span class="p">,</span> <span class="n">ks</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">norm</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="n">nxm</span> <span class="o">=</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">nym</span> <span class="o">=</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">nzm</span> <span class="o">=</span> <span class="n">nz</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

  <span class="cp">#if USE_OPENMP</span>
  <span class="cp">#pragma omp parallel default(shared) private(i,j,k)</span>
  <span class="p">{</span>
  <span class="cp">#endif</span>

    <span class="c1">// figure out where the indexing starts in the case of shared points</span>
    <span class="c1">// we&#39;ll assume the process to the &quot;left&quot; owns any duplicate points</span>
    <span class="n">is</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Ex is normal</span>
    <span class="n">js</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// load Ex values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for reduction(+:temp) collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">ks</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nz</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">js</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">ny</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">is</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nxm</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">temp</span> <span class="o">+=</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">*</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// figure out where the indexing starts in the case of shared points</span>
    <span class="n">is</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">js</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Ey is normal</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// load Ey values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for reduction(+:temp) collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">ks</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nz</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">js</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nym</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">is</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nx</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">temp</span> <span class="o">+=</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">*</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// figure out where the indexing starts in the case of shared points</span>
    <span class="n">is</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">js</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Ez is normal</span>

    <span class="c1">// load Ez values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for reduction(+:temp) collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">ks</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nzm</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">js</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">ny</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">is</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nx</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">temp</span> <span class="o">+=</span> <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">*</span> <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp barrier</span>
    <span class="cp">#pragma omp single</span>
    <span class="cp">#endif</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">eps</span><span class="o">*</span><span class="n">temp</span><span class="p">;</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp barrier</span>
    <span class="cp">#endif</span>

    <span class="c1">// figure out where the indexing starts in the case of shared points</span>
    <span class="n">is</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Hx is normal</span>
    <span class="n">js</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// load Hx values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for reduction(+:temp) collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">ks</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nzm</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">js</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nym</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">is</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nx</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">temp</span> <span class="o">+=</span> <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="o">*</span> <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>


    <span class="c1">// figure out where the indexing starts in the case of shared points</span>
    <span class="n">is</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">js</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Hy is normal</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// load Hy values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for reduction(+:temp) collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">ks</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nzm</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">js</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">ny</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">is</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nxm</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">temp</span> <span class="o">+=</span> <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">*</span> <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// figure out where the indexing starts in the case of shared points</span>
    <span class="n">is</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">js</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Hz is normal</span>

    <span class="c1">// load Hz values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for reduction(+:temp) collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">ks</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nz</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">js</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nym</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">is</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nxm</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">temp</span> <span class="o">+=</span> <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">]</span> <span class="o">*</span> <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

  <span class="cp">#if USE_OPENMP</span>
  <span class="p">}</span>
  <span class="cp">#endif</span>

  <span class="n">norm</span> <span class="o">+=</span> <span class="n">temp</span><span class="o">*</span><span class="n">mu</span><span class="p">;</span>

  <span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
  <span class="n">calc_norm_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">norm</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-to-calculate-error">
<h3>Function to Calculate Error<a class="headerlink" href="#function-to-calculate-error" title="Permalink to this headline">¶</a></h3>
<p>Finally we have a function to compute the error. This function is essentially
identical to the <code class="docutils literal notranslate"><span class="pre">norm()</span></code> function except it computes <span class="math notranslate nohighlight">\(\varepsilon \|E - E_{exact}\|^2 + \mu \|H - H_{exact}\|^2\)</span></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">yee_updater</span><span class="o">::</span><span class="n">calc_error</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">nxm</span><span class="p">,</span> <span class="n">nym</span><span class="p">,</span> <span class="n">nzm</span><span class="p">,</span> <span class="n">is</span><span class="p">,</span> <span class="n">js</span><span class="p">,</span> <span class="n">ks</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">error</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">sol</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="n">nxm</span> <span class="o">=</span> <span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">nym</span> <span class="o">=</span> <span class="n">ny</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">nzm</span> <span class="o">=</span> <span class="n">nz</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="kt">double</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
  <span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

  <span class="c1">// set the solution routine to use the exact expression for the curl</span>
  <span class="n">sol_obj</span><span class="p">.</span><span class="n">set_derivative_method</span><span class="p">(</span><span class="n">maxwell_solutions</span><span class="o">::</span><span class="n">EXACT</span><span class="p">);</span>

  <span class="cp">#if USE_OPENMP</span>
  <span class="cp">#pragma omp parallel default(shared) private(i,j,k,x,sol)</span>
  <span class="p">{</span>
  <span class="cp">#endif</span>

    <span class="c1">// figure out where the indexing starts in the case of shared points</span>
    <span class="c1">// we&#39;ll assume the process to the &quot;left&quot; owns any duplicate points</span>
    <span class="n">is</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Ex is normal</span>
    <span class="n">js</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// load Ex values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for reduction(+:temp) collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">ks</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nz</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">js</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">ny</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">is</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nxm</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">k</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">j</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">sol</span> <span class="o">=</span> <span class="n">sol_obj</span><span class="p">.</span><span class="n">get_Ex_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Etime</span><span class="p">)</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">];</span>
          <span class="n">temp</span> <span class="o">+=</span>  <span class="n">sol</span> <span class="o">*</span> <span class="n">sol</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// figure out where the indexing starts in the case of shared points</span>
    <span class="n">is</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Ey is normal</span>
    <span class="n">js</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// load Ey values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for reduction(+:temp) collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">ks</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nz</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">js</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nym</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">is</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nx</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">k</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
          <span class="n">sol</span> <span class="o">=</span> <span class="n">sol_obj</span><span class="p">.</span><span class="n">get_Ey_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Etime</span><span class="p">)</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">];</span>
          <span class="n">temp</span> <span class="o">+=</span> <span class="n">sol</span> <span class="o">*</span> <span class="n">sol</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// figure out where the indexing starts in the case of shared points</span>
    <span class="n">is</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Ez is normal</span>
    <span class="n">js</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// load Ez values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for reduction(+:temp) collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">ks</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nzm</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">js</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">ny</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">is</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nx</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">k</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">j</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
          <span class="n">sol</span> <span class="o">=</span> <span class="n">sol_obj</span><span class="p">.</span><span class="n">get_Ez_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Etime</span><span class="p">)</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">];</span>
          <span class="n">temp</span> <span class="o">+=</span> <span class="n">sol</span> <span class="o">*</span> <span class="n">sol</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp barrier</span>
    <span class="cp">#pragma omp single</span>
    <span class="cp">#endif</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">eps</span><span class="o">*</span><span class="n">temp</span><span class="p">;</span>

    <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp barrier</span>
    <span class="cp">#endif</span>

    <span class="c1">// figure out where the indexing starts in the case of shared points</span>
    <span class="n">is</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Hx is normal</span>
    <span class="n">js</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// load Hx values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for reduction(+:temp) collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">ks</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nzm</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">js</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nym</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">is</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nx</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">k</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
          <span class="n">sol</span> <span class="o">=</span> <span class="n">sol_obj</span><span class="p">.</span><span class="n">get_Hx_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Htime</span><span class="p">)</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">];</span>
          <span class="n">temp</span> <span class="o">+=</span> <span class="n">sol</span> <span class="o">*</span> <span class="n">sol</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// figure out where the indexing starts in the case of shared points</span>
    <span class="n">is</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Hy is normal</span>
    <span class="n">js</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// load Hy values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for reduction(+:temp) collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">ks</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nzm</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">js</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">ny</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">is</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nxm</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">k</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">j</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">sol</span> <span class="o">=</span> <span class="n">sol_obj</span><span class="p">.</span><span class="n">get_Hy_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Htime</span><span class="p">)</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">ny</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">];</span>
          <span class="n">temp</span> <span class="o">+=</span> <span class="n">sol</span> <span class="o">*</span> <span class="n">sol</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// figure out where the indexing starts in the case of shared points</span>
    <span class="n">is</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Hz is normal</span>
    <span class="n">js</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="p">(</span><span class="n">procBounds</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">NONE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// load Hz values</span>
    <span class="cp">#if USE_OPENMP</span>
    <span class="cp">#pragma omp for reduction(+:temp) collapse(3)</span>
    <span class="cp">#endif</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">ks</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">nz</span><span class="p">;</span> <span class="n">k</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">js</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nym</span><span class="p">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">is</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nxm</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">k</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span>
          <span class="n">sol</span> <span class="o">=</span> <span class="n">sol_obj</span><span class="p">.</span><span class="n">get_Hz_solution</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Htime</span><span class="p">)</span> <span class="o">-</span> <span class="n">H</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">nym</span><span class="p">)</span><span class="o">*</span><span class="n">nxm</span><span class="p">];</span>
          <span class="n">temp</span> <span class="o">+=</span> <span class="n">sol</span> <span class="o">*</span> <span class="n">sol</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

  <span class="cp">#if USE_OPENMP</span>
  <span class="p">}</span>
  <span class="cp">#endif</span>

  <span class="n">error</span> <span class="o">+=</span> <span class="n">temp</span><span class="o">*</span><span class="n">mu</span><span class="p">;</span>

  <span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>
  <span class="n">calc_err_t</span> <span class="o">+=</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="example-driver">
<h2>Example Driver<a class="headerlink" href="#example-driver" title="Permalink to this headline">¶</a></h2>
<p>The following code is an example of how to use the <code class="docutils literal notranslate"><span class="pre">yee_updater</span></code> class described
above to run a simulation.</p>
<p>First we the header file for the <code class="docutils literal notranslate"><span class="pre">yee_updater</span></code> class, C++ output routines and
<code class="docutils literal notranslate"><span class="pre">cmath</span></code> to get the <code class="docutils literal notranslate"><span class="pre">pow</span></code> function.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;yee_mpi.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>

  <span class="kt">int</span> <span class="n">nprocs</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">procs_per_dim</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">t</span><span class="p">,</span> <span class="n">crbc_t</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">;</span>
  <span class="n">MPI_Comm</span> <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI_COMM_WORLD</span><span class="p">;</span>
</pre></div>
</div>
<p>Next we read in some command line input so we can change some problem parameters
without having to recompile.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// read commandline input</span>
<span class="c1">// expect ./foo w n t crbc_t tol</span>
<span class="c1">// where</span>
<span class="c1">// w is the domain width</span>
<span class="c1">// n is the number of grid points</span>
<span class="c1">// t is the simulation time</span>
<span class="c1">// crbc_t is the crbc time parameter</span>
<span class="c1">// p is the number of recurions</span>
<span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

  <span class="n">w</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">atof</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">atof</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
  <span class="n">crbc_t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">atof</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
  <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>

<span class="p">}</span>
</pre></div>
</div>
<p>Then we initialize MPI and get the communicator size and the rank of each process.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// intialize MPI</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error in MPI_Init&quot;</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// start timer</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span> <span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nprocs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error in MPI_Comm_size&quot;</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MPI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error in MPI_Comm_rank&quot;</span> <span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Next, we print out the total number of processes in the communicator. We take
the cuberoot of this number to get the number of processes per spatial dimension.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;nprocs = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">nprocs</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="c1">// calculate the largest integer cube root</span>
<span class="n">procs_per_dim</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pow</span><span class="p">(</span><span class="n">nprocs</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">));</span>

<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;using &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">procs_per_dim</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; per dimension&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Next we initialize a <code class="docutils literal notranslate"><span class="pre">yee_updater</span></code> object by giving it the parameters we got
from the command line as well as telling it to generate at approximately every
0.1 (time units) and to sample every point for the error calculations.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">yee_updater</span> <span class="nf">solver</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="n">procs_per_dim</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">crbc_t</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>Finally, we try to run the simulation and print out the timing data if the run
is successful. Then we tell the solver to free the communicators it has created
so we don’t leak memory.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">try</span> <span class="p">{</span>
  <span class="n">solver</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
  <span class="n">solver</span><span class="p">.</span><span class="n">print_timing_data</span><span class="p">();</span>
  <span class="n">solver</span><span class="p">.</span><span class="n">free_comms</span><span class="p">();</span>
<span class="p">}</span> <span class="n">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;id = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; failed in solver.run() --- a standard exception was caught, with message &#39;&quot;</span>
                <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">MPI_Abort</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, we print out the timer and call <code class="docutils literal notranslate"><span class="pre">MPI_finalize()</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="n">MPI_Barrier</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">);</span>
  <span class="n">t2</span> <span class="o">=</span> <span class="n">MPI_Wtime</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Wall time = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">MPI_Finalize</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// end main</span>
</pre></div>
</div>
</div>
<div class="section" id="compiling">
<h2>Compiling<a class="headerlink" href="#compiling" title="Permalink to this headline">¶</a></h2>
<p>The most straightforward way to compile this example is to use a simple makefile.
It is also possible to use CMake, but this usually requires that the entire
YeeCRBC library be compiled with MPI compilers, which is unnecessary.</p>
<p>The following is a sample makefile that could be used:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span># specify the C and C++ MPI compilers to use
CC = mpicc
CPP = mpic++

# set the compiler flags for C and C++
CFLAGS = -Wall -DNDEBUG -O3
CPPFLAGS = -Wall -O3 -DNDEBUG -std=c++11

# specify the location of the YeeCRBC library header files. Note that the default
# install location is /usr/local/include/crbc
CPPINC = /usr/local/include/crbc

# specify the location of the optimal cosines source file (this is available
# from the utilities section of rbcpack.org or from the /src/optimal_cosines
# directory in the YeeCRBC component of rbcpack
CSRC = optimal_cosines.c
COBJ = optimal_cosines.o

# specify the locations of the C++ source files
CPPSRC = solutions.cpp yee_mpi.cpp
CPPOBJ = solutions.o yee_mpi.o

# specify the C++ driver source files
CPPDRIVER = yee_mpi_example.cpp

# specify executable name
CPPEXEC = yee_mpi_example.x

# this builds the actual executable
$(CPPEXEC) : $(CPPOBJ) $(COBJ) $(CPPDRIVER)
      $(CPP) yee_mpi_example.cpp $(CPPOBJ) $(COBJ) $(CPPFLAGS) -I$(CPPINC) -o $(CPPEXEC)

# the following build all of the object files
optimal_cosines.o : optimal_cosines.c
      $(CC) optimal_cosines.c $(CFLAGS) -c

solutions.o : solutions.cpp
      $(CPP) solutions.cpp $(CPPFLAGS) -c

yee_mpi.o : yee_mpi.cpp
      $(CPP) yee_mpi.cpp $(CPPFLAGS) -I$(CPPINC) -c

# delete the executable and all of the object files
clean :
      rm -f $(CPPOBJ) $(COBJ) $(CPPEXEC)
</pre></div>
</div>
</div>
<div class="section" id="sample-output">
<h2>Sample Output<a class="headerlink" href="#sample-output" title="Permalink to this headline">¶</a></h2>
<p>The following is an example of the output generated by running the example with
the following command</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">mpirun</span> <span class="o">-</span><span class="n">np</span> <span class="mi">8</span> <span class="p">.</span><span class="o">/</span><span class="n">yee_mpi_example</span><span class="p">.</span><span class="n">x</span> <span class="mf">1.6</span> <span class="mi">251</span> <span class="mi">5</span> <span class="mi">5</span> <span class="mi">4</span>
</pre></div>
</div>
<p>This corresponds to a problem on the domain <span class="math notranslate nohighlight">\([-0.8,0.8]^3\)</span> using 251 grid
points in each direction. This problem is run for 5 seconds using 4 CRBC recursions.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">nprocs</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">using</span> <span class="mi">2</span> <span class="n">per</span> <span class="n">dimension</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">0</span>     <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>       <span class="n">err</span> <span class="o">=</span> <span class="mf">1262.5</span>    <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.00104602</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">27</span>    <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0987685</span>       <span class="n">err</span> <span class="o">=</span> <span class="mf">2710.69</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.0022459</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">54</span>    <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.197537</span>        <span class="n">err</span> <span class="o">=</span> <span class="mf">4917.68</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.00407446</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">81</span>    <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.296305</span>        <span class="n">err</span> <span class="o">=</span> <span class="mf">7229.54</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.00598992</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">108</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.395074</span>        <span class="n">err</span> <span class="o">=</span> <span class="mf">9248.97</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.00766308</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">135</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.493842</span>        <span class="n">err</span> <span class="o">=</span> <span class="mf">8923.6</span>    <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.0073935</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">162</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.592611</span>        <span class="n">err</span> <span class="o">=</span> <span class="mf">6035.17</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.00500034</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">189</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.691379</span>        <span class="n">err</span> <span class="o">=</span> <span class="mf">3847.98</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.00318818</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">216</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.790148</span>        <span class="n">err</span> <span class="o">=</span> <span class="mf">2171.66</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.00179929</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">243</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.888916</span>        <span class="n">err</span> <span class="o">=</span> <span class="mf">913.153</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000756578</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">270</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.987685</span>        <span class="n">err</span> <span class="o">=</span> <span class="mf">376.69</span>    <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000312101</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">297</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.08645</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">226.356</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000187543</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">324</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.18522</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">212.431</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000176007</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">351</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.28399</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">210.298</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000174239</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">378</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.38276</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">208.868</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000173054</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">405</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.48153</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">207.345</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000171793</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">432</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.5803</span>  <span class="n">err</span> <span class="o">=</span> <span class="mf">205.702</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000170431</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">459</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.67906</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">204.123</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000169123</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">486</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.77783</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">202.654</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000167906</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">513</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.8766</span>  <span class="n">err</span> <span class="o">=</span> <span class="mf">201.369</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000166841</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">540</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.97537</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">200.143</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000165825</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">567</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.07414</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">199.028</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000164902</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">594</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.17291</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">197.434</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000163581</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">621</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.27167</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">195.083</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000161633</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">648</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.37044</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">193.575</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000160383</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">675</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.46921</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">192.648</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000159615</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">702</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.56798</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">191.402</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000158583</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">729</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.66675</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.822</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000158103</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">756</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.76552</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.572</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157895</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">783</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.86429</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.464</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157806</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">810</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">2.96305</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.403</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157755</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">837</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.06182</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.364</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157723</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">864</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.16059</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.344</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157707</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">891</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.25936</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.339</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157702</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">918</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.35813</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.337</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.0001577</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">945</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.4569</span>  <span class="n">err</span> <span class="o">=</span> <span class="mf">190.336</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.0001577</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">972</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.55566</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.336</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.0001577</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">999</span>   <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.65443</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.336</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.0001577</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">1026</span>  <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.7532</span>  <span class="n">err</span> <span class="o">=</span> <span class="mf">190.336</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.0001577</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">1053</span>  <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.85197</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.337</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.0001577</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">1080</span>  <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">3.95074</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.336</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.0001577</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">1107</span>  <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.04951</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.329</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157694</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">1134</span>  <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.14828</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.321</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157688</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">1161</span>  <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.24704</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.317</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157684</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">1188</span>  <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.34581</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.315</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157683</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">1215</span>  <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.44458</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.314</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157681</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">1242</span>  <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.54335</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.313</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.00015768</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">1269</span>  <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.64212</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.312</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.00015768</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">1296</span>  <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.74089</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.311</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157679</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">1323</span>  <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.83965</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.311</span>   <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157679</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">1350</span>  <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.93842</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.31</span>    <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157679</span>
<span class="n">tstep</span> <span class="o">=</span> <span class="mi">1366</span>  <span class="n">T</span> <span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">=</span> <span class="mf">4.99695</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">190.31</span>    <span class="n">rel</span> <span class="n">err</span> <span class="o">=</span> <span class="mf">0.000157679</span>
</pre></div>
</div>
<p>The example also outputs some timing data. We include it here to show the
functionality, but note that the simulation was run on a laptop so the actual
data is likely not very informative. We have formatted the output into a table
for readability.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 8%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 4%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 5%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 5%" />
<col style="width: 6%" />
<col style="width: 5%" />
<col style="width: 5%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Process ID</p></th>
<th class="head"><p>Calc Params</p></th>
<th class="head"><p>Create Comms</p></th>
<th class="head"><p>Alloc Mem</p></th>
<th class="head"><p>Init DABs</p></th>
<th class="head"><p>Step E</p></th>
<th class="head"><p>Step Inner H</p></th>
<th class="head"><p>Step Outer H</p></th>
<th class="head"><p>Step DAB</p></th>
<th class="head"><p>Send DAB</p></th>
<th class="head"><p>Recv DAB</p></th>
<th class="head"><p>Send E</p></th>
<th class="head"><p>Recv E</p></th>
<th class="head"><p>Load ICs</p></th>
<th class="head"><p>Calc Norm</p></th>
<th class="head"><p>Calc Err</p></th>
<th class="head"><p>Total</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>2.38e-07</p></td>
<td><p>0.004</p></td>
<td><p>0.10571</p></td>
<td><p>0.154</p></td>
<td><p>107.0</p></td>
<td><p>96.76</p></td>
<td><p>11.85</p></td>
<td><p>172.8</p></td>
<td><p>2.026</p></td>
<td><p>1.32</p></td>
<td><p>3.36</p></td>
<td><p>8.70</p></td>
<td><p>4.27</p></td>
<td><p>0.035</p></td>
<td><p>51.1</p></td>
<td><p>459.613</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>7.15e-07</p></td>
<td><p>0.004</p></td>
<td><p>0.10432</p></td>
<td><p>0.152</p></td>
<td><p>105.0</p></td>
<td><p>97.86</p></td>
<td><p>12.30</p></td>
<td><p>171.7</p></td>
<td><p>1.890</p></td>
<td><p>1.46</p></td>
<td><p>3.64</p></td>
<td><p>10.4</p></td>
<td><p>4.20</p></td>
<td><p>0.034</p></td>
<td><p>50.7</p></td>
<td><p>459.673</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>2.38e-07</p></td>
<td><p>4e-05</p></td>
<td><p>0.105881</p></td>
<td><p>0.154</p></td>
<td><p>105.6</p></td>
<td><p>97.77</p></td>
<td><p>11.81</p></td>
<td><p>172.9</p></td>
<td><p>2.047</p></td>
<td><p>1.15</p></td>
<td><p>3.59</p></td>
<td><p>10.9</p></td>
<td><p>4.25</p></td>
<td><p>0.035</p></td>
<td><p>50.8</p></td>
<td><p>461.456</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>2.38e-07</p></td>
<td><p>4e-05</p></td>
<td><p>0.104705</p></td>
<td><p>0.152</p></td>
<td><p>103.3</p></td>
<td><p>95.33</p></td>
<td><p>12.45</p></td>
<td><p>171.5</p></td>
<td><p>1.354</p></td>
<td><p>1.74</p></td>
<td><p>3.90</p></td>
<td><p>15.3</p></td>
<td><p>4.18</p></td>
<td><p>0.034</p></td>
<td><p>49.6</p></td>
<td><p>459.253</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>2.38e-07</p></td>
<td><p>0.004</p></td>
<td><p>0.106265</p></td>
<td><p>0.154</p></td>
<td><p>105.3</p></td>
<td><p>96.20</p></td>
<td><p>12.06</p></td>
<td><p>173.2</p></td>
<td><p>1.663</p></td>
<td><p>1.36</p></td>
<td><p>3.98</p></td>
<td><p>12.2</p></td>
<td><p>4.28</p></td>
<td><p>0.039</p></td>
<td><p>50.3</p></td>
<td><p>460.99</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>2.38e-07</p></td>
<td><p>0.004</p></td>
<td><p>0.104194</p></td>
<td><p>0.153</p></td>
<td><p>102.9</p></td>
<td><p>94.03</p></td>
<td><p>12.51</p></td>
<td><p>170.6</p></td>
<td><p>0.9274</p></td>
<td><p>1.57</p></td>
<td><p>4.46</p></td>
<td><p>17.7</p></td>
<td><p>4.17</p></td>
<td><p>0.034</p></td>
<td><p>49.8</p></td>
<td><p>459.23</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>2.38e-07</p></td>
<td><p>0.004</p></td>
<td><p>0.0990539</p></td>
<td><p>0.154</p></td>
<td><p>105.8</p></td>
<td><p>95.70</p></td>
<td><p>12.23</p></td>
<td><p>173.1</p></td>
<td><p>1.756</p></td>
<td><p>1.02</p></td>
<td><p>3.56</p></td>
<td><p>13.4</p></td>
<td><p>4.21</p></td>
<td><p>0.034</p></td>
<td><p>50.2</p></td>
<td><p>461.609</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>7.15e-07</p></td>
<td><p>0.004</p></td>
<td><p>0.103947</p></td>
<td><p>0.149</p></td>
<td><p>104.0</p></td>
<td><p>96.83</p></td>
<td><p>12.85</p></td>
<td><p>170.7</p></td>
<td><p>1.408</p></td>
<td><p>1.65</p></td>
<td><p>3.58</p></td>
<td><p>13.6</p></td>
<td><p>4.14</p></td>
<td><p>0.034</p></td>
<td><p>48.7</p></td>
<td><p>458.085</p></td>
</tr>
<tr class="row-even"><td><p>Total</p></td>
<td><p>2.86e-06</p></td>
<td><p>0.024</p></td>
<td><p>0.834076</p></td>
<td><p>1.226</p></td>
<td><p>839.4</p></td>
<td><p>770.5</p></td>
<td><p>98.10</p></td>
<td><p>1376</p></td>
<td><p>13.07</p></td>
<td><p>11.3</p></td>
<td><p>30.1</p></td>
<td><p>102</p></td>
<td><p>33.7</p></td>
<td><p>0.281</p></td>
<td><p>401</p></td>
<td><p>3679.91</p></td>
</tr>
</tbody>
</table>
</div>
</div>


    </div>
      
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/YeeCRBC/yee_mpi.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
    <a href="../contrib.html">rbcpack Contributors </a><br />
        &copy; Copyright 2015-2016, rbcpack.org.<br/>
    </p>
  </div>
</footer>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71984541-1', 'auto');
  ga('send', 'pageview');

</script>


  </body>
</html>