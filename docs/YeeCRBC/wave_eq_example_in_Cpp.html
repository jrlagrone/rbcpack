<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wave Equation code with CRBC/DAB Boundary Conditions &#8212; RBCPack  documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="3-D FDTD code with CRBC/DAB Boundary Conditions using MPI" href="yee_mpi.html" />
    <link rel="prev" title="3-D FDTD code with CRBC/DAB Boundary Conditions" href="3D_Yee_example_in_C.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          rbcpack</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Components <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Yee/FDTD</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#downloads-and-respository">Downloads and Respository</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#documentation">Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/index.html">Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Utilities/index.html#optimal-cosines">Optimal Cosines</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contrib.html">rbcpack Contributors</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Current Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Wave Equation code with CRBC/DAB Boundary Conditions</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#what-this-program-does">What this program does</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-commented-program">The commented program</a><ul>
<li><a class="reference internal" href="#include-files">Include files</a></li>
<li><a class="reference internal" href="#wave-equation-class">wave_equation class</a><ul>
<li><a class="reference internal" href="#data-storage">Data storage</a></li>
<li><a class="reference internal" href="#private-functions">Private Functions</a><ul>
<li><a class="reference internal" href="#time-step">time_step()</a></li>
<li><a class="reference internal" href="#apply-driving">apply_driving()</a></li>
<li><a class="reference internal" href="#step-boundaries">step_boundaries()</a></li>
<li><a class="reference internal" href="#write-output">write_output()</a></li>
</ul>
</li>
<li><a class="reference internal" href="#public-functions">Public Functions</a><ul>
<li><a class="reference internal" href="#constructor">Constructor</a></li>
<li><a class="reference internal" href="#run">run()</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#main-routine">Main Routine</a></li>
</ul>
</li>
<li><a class="reference internal" href="#output">Output</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="3D_Yee_example_in_C.html" title="Previous Chapter: 3-D FDTD code with CRBC/DAB Boundary Conditions"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 3-D FDTD code...</span>
    </a>
  </li>
  <li>
    <a href="yee_mpi.html" title="Next Chapter: 3-D FDTD code with CRBC/DAB Boundary Conditions using MPI"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">3-D FDTD code... &raquo;</span>
    </a>
  </li>
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary">  <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Yee/FDTD</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#downloads-and-respository">Downloads and Respository</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#licensing">Licensing</a></li>
</ul>
</li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#documentation">Documentation</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="index.html#user-guides">User Guides</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#known-issues">Known Issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#theory-results-and-publications">Theory, Results, and Publications</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Utilities/index.html">Utilities</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../Utilities/index.html#optimal-cosines">Optimal Cosines</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contrib.html">rbcpack Contributors</a></li>
</ul>

<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <div class="section" id="wave-equation-code-with-crbc-dab-boundary-conditions">
<h1>Wave Equation code with CRBC/DAB Boundary Conditions<a class="headerlink" href="#wave-equation-code-with-crbc-dab-boundary-conditions" title="Permalink to this headline">¶</a></h1>
<p>This tutorial explains the code <a class="reference external" href="https://github.com/jrlagrone/rbcpack/blob/main/YeeCRBC/examples/wave_cxx/wave_eq.cpp">wave_eq.cpp</a>.</p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This C++ code implements the finite difference time-domain solution of
the scalar wave equation using standard second order centered differencing in
one, two, and three dimensions. The grid is terminated using Double Absorbing
Boundaries (DAB).</p>
<p>This is meant to serve as an example of how one might use the underlying
C++ interface to the CRBC/DAB library. This interface is templated and
supports up to three dimensions. It is also templated on the internal
indexing and data types.</p>
<div class="section" id="what-this-program-does">
<h3>What this program does<a class="headerlink" href="#what-this-program-does" title="Permalink to this headline">¶</a></h3>
<p>For this example, we consider the scalar, constant coefficient, wave equation in
one, two, and three dimensions.</p>
<div class="math notranslate nohighlight">
\[\frac{\partial^2 u}{\partial t^2} = c^2 \sum\limits_{i=1}^N \frac{\partial^2 u}{\partial x_i^2}, \qquad N=\{1,2,3\}.\]</div>
<p>We discretize using the standard second order centered differences,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{\partial^2 u}{\partial t^2} (\mathbf{x}, t) &amp; \Rightarrow \frac{u^{t+\Delta t}(\mathbf{x}) - 2 u^{t}(\mathbf{x}) + u^{t - \Delta t}(\mathbf{x})} {(\Delta t)^2}, \\
\frac{\partial^2 u}{\partial x_i^2} (\mathbf{x}, t) &amp; \Rightarrow \frac{u^{t}(\mathbf{x} + h_i \mathbf{e}_i) - 2 u^{t}(\mathbf{x}) + u^{t}(\mathbf{x} - h_i \mathbf{e}_i)} {(h_i)^2},\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{e}_i\)</span> is the <em>ith</em> canonical basis vector, <span class="math notranslate nohighlight">\(h_i\)</span> is
the grid spacing in the <em>ith</em> coordinate direction, and the time step, <span class="math notranslate nohighlight">\(\Delta t\)</span>,
is chosen to satisfy the CFL condition</p>
<div class="math notranslate nohighlight">
\[\Delta t \leq \frac{1}{c \sqrt{\sum\limits_{i=1}^N \frac{1}{h_i^2}}}.\]</div>
<p>Solving for <span class="math notranslate nohighlight">\(u^{t + \Delta t}(\mathbf{x})\)</span>, we get the update equation</p>
<div class="math notranslate nohighlight">
\[u^{t + \Delta t}(\mathbf{x}) = 2 u^{t}(\mathbf{x}) - u^{t - \Delta t}(\mathbf{x})
  + c^2 (\Delta t)^2 \sum\limits_{i=1}^N \frac{u^{t}(\mathbf{x} + h_i \mathbf{e}_i)
  - 2 u^{t}(\mathbf{x}) + u^{t}(\mathbf{x} - h_i \mathbf{e}_i)} {h_i^2}, \qquad N=\{1,2,3\}.\]</div>
</div>
</div>
<div class="section" id="the-commented-program">
<h2>The commented program<a class="headerlink" href="#the-commented-program" title="Permalink to this headline">¶</a></h2>
<div class="section" id="include-files">
<h3>Include files<a class="headerlink" href="#include-files" title="Permalink to this headline">¶</a></h3>
<p>First we define some macros to make the indexing in the code a little bit cleaner.
<code class="docutils literal notranslate"><span class="pre">i2d</span></code> handles the indexing in 2D and <code class="docutils literal notranslate"><span class="pre">i3d</span></code> handles the indexing in 3D.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// define some macros for indexing</span>
<span class="cp">#define i2d(i,j) (i + (j)*imax[0])</span>
<span class="cp">#define i3d(i,j,k) (i + imax[0]*((j) + (k)*imax[1]))</span>
<span class="cp">#define PI std::atan(1.0)*4</span>
</pre></div>
</div>
<p>We will require the following includes:</p>
<p>This file contains the most generic C++ interface to the CRBC/DAB boundary
conditions.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;crbc_updates.hpp&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>For C++ strings,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>So we can append ints to strings, we use</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>Simple file output requires</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>For general output, we need</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>We use this to get std::swap so we can swap pointers for arrays and vectors
without having to copy data. Note that as of C++11, std::swap is suppose to
move to &lt;utility&gt;, so this may need to be changed depending on your compiler.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>This has the declarations of the <code class="docutils literal notranslate"><span class="pre">sqrt()</span></code> and <code class="docutils literal notranslate"><span class="pre">abs()</span></code> functions</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="section" id="wave-equation-class">
<h3>wave_equation class<a class="headerlink" href="#wave-equation-class" title="Permalink to this headline">¶</a></h3>
<p>We begin by creating a class to handle the wave equation updates along with
all of the data. We use templates so that the same code can be used to handle
1, 2, or 3 dimensions. We define everything in the class inline so the example
is more contained, but we note that one should typically declare the class and
provide the definitions elsewhere.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="kt">int</span> <span class="n">DIM</span><span class="o">&gt;</span>
<span class="n">class</span> <span class="n">wave_equation</span>
<span class="p">{</span>

  <span class="nl">private</span><span class="p">:</span>
</pre></div>
</div>
<div class="section" id="data-storage">
<h4>Data storage<a class="headerlink" href="#data-storage" title="Permalink to this headline">¶</a></h4>
<p>First we declare all of the storage that we will need. We declare the boundary
conditions to be of the boundary type that the CRBC library uses internally.
These are provided as an enumeration in the <code class="docutils literal notranslate"><span class="pre">BoundaryProperties</span></code> class that
is in the <code class="docutils literal notranslate"><span class="pre">crbc</span></code> namespace. For clarity, we always provide the namespace and
class scopes where appropriate. Finally, we declare a CRBC updater object
with the template parameters <code class="docutils literal notranslate"><span class="pre">&lt;DIM,</span> <span class="pre">double,</span> <span class="pre">int&gt;</span></code> so that we are using <em>DIM</em>
dimensions, the field values will be stored as a <code class="docutils literal notranslate"><span class="pre">double</span></code> type, and we will use
the <code class="docutils literal notranslate"><span class="pre">int</span></code> type for indexing.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// arrays to hold old, current, and new wave equation values</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">old_data</span><span class="p">,</span> <span class="n">cur_data</span><span class="p">,</span> <span class="n">new_data</span><span class="p">;</span>

<span class="kt">double</span> <span class="n">c</span><span class="p">;</span>       <span class="c1">// wave speed</span>
<span class="kt">double</span> <span class="n">dt</span><span class="p">;</span>      <span class="c1">// time step</span>
<span class="kt">double</span> <span class="n">h</span><span class="p">[</span><span class="n">DIM</span><span class="p">];</span>  <span class="c1">// grid spacings</span>

<span class="kt">int</span> <span class="n">ntsteps</span><span class="p">;</span>   <span class="c1">// number of time steps</span>
<span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// number of grid points</span>
<span class="kt">int</span> <span class="n">imax</span><span class="p">[</span><span class="n">DIM</span><span class="p">];</span> <span class="c1">// indexing limits in each direction</span>
<span class="kt">int</span> <span class="n">out_freq</span><span class="p">;</span>  <span class="c1">// output frequency, in time steps</span>
<span class="kt">int</span> <span class="n">src</span><span class="p">[</span><span class="n">DIM</span><span class="p">];</span>  <span class="c1">// source location</span>

<span class="kt">bool</span> <span class="n">save_output</span><span class="p">;</span> <span class="c1">// flag indicating whether we should save the field vals.</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">base_name</span><span class="p">;</span> <span class="c1">// base file name for output</span>

<span class="c1">// Boundary conditions. We will use the boundaries enumerations provided</span>
<span class="c1">// by the BoundaryProperties class in the CRBC library.</span>
<span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">Boundary</span> <span class="n">boundaries</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">DIM</span><span class="p">];</span>

<span class="c1">// a CRBC updater object to handle the boundaries</span>
<span class="n">crbc</span><span class="o">::</span><span class="n">CrbcUpdates</span><span class="o">&lt;</span><span class="n">DIM</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">boundary_updater</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="private-functions">
<h4>Private Functions<a class="headerlink" href="#private-functions" title="Permalink to this headline">¶</a></h4>
<div class="section" id="time-step">
<h5>time_step()<a class="headerlink" href="#time-step" title="Permalink to this headline">¶</a></h5>
<p>This function computes the wave equation updates using standard second order,
centered differences for the values in the interior of the domain. For simplicity,
we explicitly differentiate each of the possible dimensions.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">time_step</span><span class="p">()</span> <span class="p">{</span>

  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>

  <span class="kt">double</span> <span class="n">b</span><span class="p">[</span><span class="n">DIM</span><span class="p">];</span>

  <span class="c1">// precompute coefficients</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">DIM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

  <span class="c1">// loop over the internal grid points and apply the wave equation</span>
  <span class="c1">// update in the appropriate number of dimensions</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">DIM</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="c1">// 1D</span>

      <span class="c1">//   unew = 2ucur - uold + dt^2*c^2/h_{x}^2 *(u_{x_i-1} - 2u_{x_i} + u_{x_i+1})</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">new_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">old_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> \
          <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">cur_data</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="c1">// 2D</span>

      <span class="c1">//   unew = 2ucur - uold + dt^2*c^2/h_{x}^2 *(u_{x_i-1} - 2u_{x_i} + u_{x_i+1})</span>
      <span class="c1">//                       + dt^2*c^2/h_{y}^2 *(u_{y_i-1} - 2u_{y_i} + u_{y_i+1})</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

          <span class="n">new_data</span><span class="p">[</span><span class="n">i2d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i2d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">-</span> <span class="n">old_data</span><span class="p">[</span><span class="n">i2d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> \
            <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i2d</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i2d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> \
            <span class="o">+</span> <span class="n">cur_data</span><span class="p">[</span><span class="n">i2d</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)])</span> \
            <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i2d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i2d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> \
            <span class="o">+</span> <span class="n">cur_data</span><span class="p">[</span><span class="n">i2d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)]);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="mi">3</span><span class="o">:</span> <span class="c1">// 3D</span>

      <span class="c1">//   unew = 2ucur - uold + dt^2*c^2/h_{x}^2 *(u_{x_i-1} - 2u_{x_i} + u_{x_i+1})</span>
      <span class="c1">//                       + dt^2*c^2/h_{y}^2 *(u_{y_i-1} - 2u_{y_i} + u_{y_i+1})</span>
      <span class="c1">//                       + dt^2*c^2/h_{z}^2 *(u_{z_i-1} - 2u_{z_i} + u_{z_i+1})</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">imax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">new_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)]</span> <span class="o">-</span> <span class="n">old_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)]</span> \
              <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)]</span> \
              <span class="o">+</span> <span class="n">cur_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)])</span> \
              <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)]</span> \
              <span class="o">+</span> <span class="n">cur_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">)])</span> \
              <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">cur_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)]</span> \
              <span class="o">+</span> <span class="n">cur_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)]);</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span>
      <span class="c1">// In practice one should probably specify the exceptions for better error</span>
      <span class="c1">// handling, but for a simple example this should be fine.</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; Unsupported dimension in the time_step() function&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">throw</span><span class="p">;</span>

  <span class="p">}</span>

<span class="p">};</span>  <span class="c1">// end time_step()</span>
</pre></div>
</div>
</div>
<div class="section" id="apply-driving">
<h5>apply_driving()<a class="headerlink" href="#apply-driving" title="Permalink to this headline">¶</a></h5>
<p>This function applies a source term at the requested grid point. For this example
we use <span class="math notranslate nohighlight">\(\sin( c \pi t)\)</span> and scale it differently depending on the dimension.
We apply this driving as a <em>soft</em> source.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">apply_driving</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">tstep</span><span class="p">)</span>
<span class="p">{</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">DIM</span><span class="p">)</span>
  <span class="p">{</span>

    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
      <span class="n">new_data</span><span class="p">[</span><span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">tstep</span><span class="o">*</span><span class="n">PI</span><span class="o">*</span><span class="n">dt</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
      <span class="n">new_data</span><span class="p">[</span><span class="n">i2d</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">src</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">+=</span> <span class="mf">5.</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">tstep</span><span class="o">*</span><span class="n">PI</span><span class="o">*</span><span class="n">dt</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
      <span class="n">new_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">src</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">src</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span> <span class="o">+=</span> <span class="mf">100.</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">tstep</span><span class="o">*</span><span class="n">PI</span><span class="o">*</span><span class="n">dt</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
      <span class="c1">// simple error handling</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; Unsupported dimension in the apply_driving() function&quot;</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">throw</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">};</span> <span class="c1">// end apply_driving</span>
</pre></div>
</div>
</div>
<div class="section" id="step-boundaries">
<h5>step_boundaries()<a class="headerlink" href="#step-boundaries" title="Permalink to this headline">¶</a></h5>
<p>This function is used to apply boundary updates. We demonstrate
using the CRBC library and homogeneous Dirichlet boundaries. Note the
CRBC library also supports homogeneous Neumann boundaries.</p>
<p>Since we initialized the fields to be 0, Dirichlet boundaries are
automatically enforced. So we need only apply the CRBC type boundaries.
If using Neumann boundaries, these should be applied where possible before
applying the CRBC library updates.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">step_boundaries</span><span class="p">()</span>
<span class="p">{</span>

  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">low_ind</span><span class="p">[</span><span class="n">DIM</span><span class="p">],</span> <span class="n">high_ind</span><span class="p">[</span><span class="n">DIM</span><span class="p">],</span> <span class="n">ind</span><span class="p">[</span><span class="n">DIM</span><span class="p">];</span>

  <span class="c1">// First we need to copy the new values into the CRBC updater object</span>
  <span class="c1">// loop over the boundary faces:</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">*</span><span class="n">DIM</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// check to see if this is a face that the CRBC updater is handling</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>If the boundary type is <code class="docutils literal notranslate"><span class="pre">crbc::BoundaryProperties::CRBC</span></code>, we ask the boundary
updater which values it expects to receive as input and then provide the requested
values to the boundary updater.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>    <span class="c1">// get the indices the updater object expects as input from this face.</span>
    <span class="c1">// Note that these values are inclusive</span>
    <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_input_extents</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">low_ind</span><span class="p">,</span> <span class="n">high_ind</span><span class="p">);</span>

    <span class="c1">// Copy the updated values into CRBC library object. Again, we note that</span>
    <span class="c1">// we explicitly handle each of the dimensions for simplicity.</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">DIM</span><span class="p">)</span> <span class="p">{</span>

      <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
          <span class="n">boundary_updater</span><span class="p">.</span><span class="n">load_face_data</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="n">new_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">boundary_updater</span><span class="p">.</span><span class="n">load_face_data</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">new_data</span><span class="p">[</span><span class="n">i2d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]);</span>
         <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">k</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
              <span class="n">boundary_updater</span><span class="p">.</span><span class="n">load_face_data</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">new_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)]);</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">break</span><span class="p">;</span>

      <span class="k">default</span><span class="o">:</span>
        <span class="c1">// simple error handling</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Unsupported dimension in the step_boundaries() function&quot;</span>
                  <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">throw</span><span class="p">;</span>


    <span class="p">}</span>
  <span class="p">}</span> <span class="c1">//end if</span>
<span class="p">}</span> <span class="c1">// end loop over faces</span>
</pre></div>
</div>
<p>After we have input the new values into the boundary updater, we can let the CRBC
library compute the boundary updates.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Now we can tell the CRBC library boundary updater to compute the updates</span>
<span class="n">boundary_updater</span><span class="p">.</span><span class="n">compute_updates</span><span class="p">();</span>
</pre></div>
</div>
<p>Finally, we need to copy the updated boundary values from the CRBC library
We again loop over all of the faces, but this time we request the output
data extents from the updater object and then copy the new values into
the appropriate locations.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">*</span><span class="n">DIM</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// check to see if this is a face that the CRBC updater is handling</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">)</span> <span class="p">{</span>

      <span class="c1">// get the indices the updater object expects as input from this face.</span>
      <span class="c1">// Note that these values are inclusive</span>
      <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_output_extents</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">low_ind</span><span class="p">,</span> <span class="n">high_ind</span><span class="p">);</span>

      <span class="c1">// Copy the updated values from the crbc updater object.</span>
      <span class="k">switch</span> <span class="p">(</span><span class="n">DIM</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>

          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">new_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_new_face_vals</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>

          <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>

          <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
              <span class="n">new_data</span><span class="p">[</span><span class="n">i2d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_new_face_vals</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
           <span class="p">}</span>
          <span class="p">}</span>

          <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>

          <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">k</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="n">low_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">high_ind</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="n">new_data</span><span class="p">[</span><span class="n">i3d</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_new_face_vals</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">ind</span><span class="p">);</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">}</span>

          <span class="k">break</span><span class="p">;</span>

        <span class="k">default</span><span class="o">:</span>
          <span class="c1">// simple error handling</span>
          <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; Unsupported dimension in the step_boundaries() function&quot;</span>
                    <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
          <span class="n">throw</span><span class="p">;</span>

      <span class="p">}</span>
    <span class="p">}</span> <span class="c1">//end if</span>
  <span class="p">}</span> <span class="c1">// end loop over faces</span>

<span class="p">};</span> <span class="c1">// end step_boundaries()</span>
</pre></div>
</div>
</div>
<div class="section" id="write-output">
<h5>write_output()<a class="headerlink" href="#write-output" title="Permalink to this headline">¶</a></h5>
<p>This function writes the most up to date field values out to an ASCII vtk file
that can be easily opened in visualization software such as ParaView.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="kt">void</span> <span class="nf">write_output</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">fname</span><span class="p">)</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">j</span><span class="p">,</span> <span class="n">cells</span><span class="p">;</span>

    <span class="c1">// calculate the number of cells</span>
    <span class="n">cells</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">DIM</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">cells</span> <span class="o">*=</span> <span class="p">(</span><span class="n">imax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="c1">// open output file</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">outfile</span><span class="p">;</span>
    <span class="n">outfile</span><span class="p">.</span><span class="n">open</span><span class="p">(</span><span class="n">fname</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>

    <span class="c1">// write out the basic VTK header info</span>
    <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;# vtk DataFile Version 3.0&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;vtk output&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ASCII&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;DATASET RECTILINEAR_GRID&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// set the dimensions. note that this needs to be in 3D regardless of the</span>
    <span class="c1">// actual dimension.</span>
    <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;DIMENSIONS &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">DIM</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">DIM</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">imax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;1 1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// save the coordinates</span>
    <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;X_COORDINATES &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; float&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Y_COORDINATES &quot;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">DIM</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; float&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; float&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Z_COORDINATES &quot;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">DIM</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">imax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; float&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">imax</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; float&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// set up a cell and field</span>
    <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CELL_DATA &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cells</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;POINT_DATA &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;FIELD FieldData 1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;wave 1 &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; double&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// now actually write the data, just a new line after every entry because</span>
    <span class="c1">// some systems have a character per line limit that we don&#39;t want to hit</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">new_data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// close file</span>
    <span class="n">outfile</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>

  <span class="p">};</span> <span class="c1">// end write output</span>


<span class="nl">public</span><span class="p">:</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="public-functions">
<h4>Public Functions<a class="headerlink" href="#public-functions" title="Permalink to this headline">¶</a></h4>
<div class="section" id="constructor">
<h5>Constructor<a class="headerlink" href="#constructor" title="Permalink to this headline">¶</a></h5>
<p>Here, we’ll specify the number of grid points in each direction and the
spacings as well as the wave speed, boundary conditions and the number of
time steps. Finally the output frequency, file name base, and the
grid point to place the source are inputs.</p>
<p>We begin by copying the inputs where necessary, calculating additional parameters
such as the time step size and allocating the storage for the field values.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">wave_equation</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">grid_points</span><span class="p">[</span><span class="n">DIM</span><span class="p">],</span>
               <span class="k">const</span> <span class="kt">double</span> <span class="n">grid_spacing</span><span class="p">[</span><span class="n">DIM</span><span class="p">],</span>
               <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span>
               <span class="k">const</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">Boundary</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">DIM</span><span class="p">],</span>
               <span class="k">const</span> <span class="kt">int</span> <span class="n">ntsteps</span><span class="p">,</span>
               <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">base_file_name</span><span class="p">,</span>
               <span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">out_freq</span><span class="p">,</span>
               <span class="k">const</span> <span class="kt">int</span> <span class="n">src_location</span><span class="p">[</span><span class="n">DIM</span><span class="p">])</span>
<span class="p">{</span>

  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">low</span><span class="p">[</span><span class="n">DIM</span><span class="p">],</span> <span class="n">high</span><span class="p">[</span><span class="n">DIM</span><span class="p">];</span>
  <span class="kt">double</span> <span class="n">T</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">tol</span><span class="p">;</span>

  <span class="c1">// first we&#39;ll save the inputs</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">DIM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">imax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid_points</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid_spacing</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">src</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">src_location</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">*</span><span class="n">DIM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">boundaries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">ntsteps</span> <span class="o">=</span> <span class="n">ntsteps</span><span class="p">;</span>
  <span class="n">base_name</span> <span class="o">=</span> <span class="n">base_file_name</span><span class="p">;</span>
  <span class="n">this</span><span class="o">-&gt;</span><span class="n">out_freq</span> <span class="o">=</span> <span class="n">out_freq</span><span class="p">;</span>

  <span class="c1">// calculate the time step size (0.99 * cfl)</span>
  <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">DIM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">+=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.99</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="p">));</span>

  <span class="c1">// calculate the total simulation time</span>
  <span class="n">T</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">ntsteps</span><span class="p">;</span>

  <span class="c1">// calculate the total number of grid points</span>
  <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">DIM</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">*=</span> <span class="n">imax</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

  <span class="c1">// initialize the data storage to be zero</span>
  <span class="n">new_data</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="n">cur_data</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="n">old_data</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</pre></div>
</div>
<p>Next we initialize the CRBC updater object. There are currently two constructors
available. In both cases, we have to provide the CRBC <em>T</em> parameter which is generally
just the total simulation time (in some situations it makes sense to choose a smaller
value — this is discussed in the general documentation). We also have to provide
the grid spacings, time step size, wave speed, and the boundary conditions. The
second constructor allows one to additionally change the default number of
recursions that are used (the default is 5).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Now initialize the CRBC updater object (by assignment)</span>
<span class="n">boundary_updater</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">CrbcUpdates</span><span class="o">&lt;</span><span class="n">DIM</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">);</span>

<span class="c1">// Note we can change the default number of recursions from 5 to, say, 7 by</span>
<span class="c1">// instead using the following constructor:</span>
<span class="c1">// boundary_updater = crbc::CrbcUpdates&lt;DIM, double, int&gt; (T, h, dt, c, boundaries, 7);</span>
</pre></div>
</div>
<p>After initializing the updater object, we need to set up the parameters for each
of the faces. This can currently be done in 3 different ways. The main difference
is how we choose the number of recursions: we can use the defaults, we can specify
the number of recursions, or we can specify a tolerance and the number of
recursions can be determined based on this tolerance.</p>
<p>First we need to calculate the minimum distance, delta, between the current boundary
side and any sources, scatterers, or other inhomogeneities. In this example,
this is simply the distance from the boundary to the source in the direction
of the inward pointing normal to the boundary.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// We begin by looping over all of the possible sides:</span>
<span class="k">for</span> <span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">*</span><span class="n">DIM</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// check to see if this is a face that the CRBC updater is handling.</span>
  <span class="c1">// NOTE that the sides are assumed to be in the following order</span>
  <span class="c1">//   left side in x  := 0</span>
  <span class="c1">//   right side in x := 1</span>
  <span class="c1">//   left side in y  := 2</span>
  <span class="c1">//   right side in y := 3</span>
  <span class="c1">//   left side in z  := 4</span>
  <span class="c1">//   right side in z := 5</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">boundaries</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// calculate the minimum separation between the boudary</span>
    <span class="c1">//</span>
    <span class="c1">// note if the boundary is on the left this distance is just the</span>
    <span class="c1">// appropriate component of the source location time the grid spacing</span>
    <span class="c1">// hence the (l%2)</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">src</span><span class="p">[</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">l</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">imax</span><span class="p">[</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">l</span><span class="o">/</span><span class="mi">2</span><span class="p">];</span>
</pre></div>
</div>
<p>The boundary updater attempts to communicate with the indexing native to the
solver, so we need to input the data extents for each boundary. We also need
to call one of the <code class="docutils literal notranslate"><span class="pre">init_face()</span></code> routines. We demonstrate a different
<code class="docutils literal notranslate"><span class="pre">init_face</span></code> routine for each dimension.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// handle the different dimensions explicitly</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">DIM</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="c1">// 1D</span>
</pre></div>
</div>
<p>For the 1D case we will illustrate the initializer where we
specify the number of recursions because using 0 recursions, which corresponds to
using Sommerfeld radiation boundary conditions, is exact (up to discretization)
in this case. The CRBC boundary updater needs to know the index of the point on
the boundary as well as the index of the point immediately interior to the
boundary. So if this is the left boundary, the extents are [0,1]. For the right
boundary, the extents are [imax[0]-2, imax[0]-1].
The updater expects these to be inclusive.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// left side</span>
  <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// right side</span>
  <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
  <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">boundary_updater</span><span class="p">.</span><span class="n">init_face</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<p>For the 2D case we will illustrate the default initializer.
In 2D the updater needs to know the indexing extents for the
line of points on the boundary as well as the parallel line
of points immediately interior to the boundary.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="mi">2</span><span class="o">:</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// left boundary in x, need [0,1] in x, all in y</span>
    <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// right boundary in x, need [imax[0]-2, imax[0]-1] in x, all y</span>
    <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// left boundary in y, need [0,1] in y, all in x</span>
    <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// right boundary in y, need [imax[1]-2, imax[1]-1] in y, all x</span>
    <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
    <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// call initializer</span>
  <span class="n">boundary_updater</span><span class="p">.</span><span class="n">init_face</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">delta</span><span class="p">);</span>
  <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<p>For the 3D case, we will use the tolerance based initializer.
This tolerance controls the reflection coefficient of the
boundary. In general, this usually provides a reasonable estimate
of the relative error due to the boundary. Some thought should
be given to its choice, using too tight of a tolerance results
in more work being done for little or no accuracy benefit and
too loose of a tolerance results in the boundary error dominating.
A good choice is typically on the order of the expected
discretization error. Here we’ll just choose 1e-2.
In 3D the updater needs to know the indexing extents for the
plane of points on the boundary as well as the parallel plane
of points immediately interior to the boundary.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>      <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>

        <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-2</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// left boundary in x, need [0,1] in x, all in y, z</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// right boundary in x, need [imax[0]-2, imax[0]-1] in x, all y, z</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// left boundary in y, need [0,1] in y, all in x, z</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// right boundary in y, need [imax[1]-2, imax[1]-1] in y, all x, z</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// left boundary in z, need [0,1] in z, all in x, y</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// right boundary in z, need [imax[2]-2, imax[2]-1] in z, all x, y</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">low</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">high</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">imax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// call initializer and limit the number of recursions to at most 20</span>
        <span class="n">boundary_updater</span><span class="p">.</span><span class="n">init_face</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">tol</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>

      <span class="k">default</span><span class="o">:</span>
        <span class="c1">// simple error handling</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; Unsupported dimension in the constructor&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">throw</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span> <span class="c1">// end loop over sides</span>
</pre></div>
</div>
<p>Finally, we’ll print out some information from the boundary updater.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>  <span class="c1">// Now we&#39;ll print out some information from the boundary updater.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Recursion properties by face &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot;(reflection coef =-1 means that no updates are performed):&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  Left side in x:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    recursions      = &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_num_recursions</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    reflection coef = &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_reflection_coef</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  Right side in x:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    recursions      = &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_num_recursions</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    reflection coef = &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_reflection_coef</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">DIM</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  Left side in y:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    recursions      = &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_num_recursions</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    reflection coef = &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_reflection_coef</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  Right side in y:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    recursions      = &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_num_recursions</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    reflection coef = &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_reflection_coef</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">DIM</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  Left side in z:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    recursions      = &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_num_recursions</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    reflection coef = &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_reflection_coef</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  Right side in z:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    recursions      = &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_num_recursions</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    reflection coef = &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_reflection_coef</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;The maximum reflection coeficient is &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_max_reflection_coef</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>


  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;The CRBC library is updating&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_num_faces</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; faces&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_num_edges</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; edges&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">boundary_updater</span><span class="p">.</span><span class="n">get_num_corners</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="s">&quot; corners&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="p">}</span> <span class="c1">// end constructor</span>
</pre></div>
</div>
<p>Additionally, we include a function to enable/disable the writing of output files.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">set_write_output</span><span class="p">(</span><span class="k">const</span> <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">write_out</span><span class="p">)</span> <span class="p">{</span><span class="n">save_output</span> <span class="o">=</span> <span class="n">write_out</span><span class="p">;};</span>
</pre></div>
</div>
</div>
<div class="section" id="run">
<h5>run()<a class="headerlink" href="#run" title="Permalink to this headline">¶</a></h5>
<p>This function simply runs the simulation by applying the time stepping, then the
source, and finally the boundary conditions. Furthermore it generates the names
for the output and permutes the data storage using pointer swapping.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>

  <span class="kt">int</span> <span class="n">t</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">fname</span><span class="p">;</span>

  <span class="c1">// time step:</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">t</span><span class="o">&lt;</span><span class="n">ntsteps</span><span class="p">;</span> <span class="o">++</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// time step the interior</span>
    <span class="n">time_step</span><span class="p">();</span>

    <span class="c1">// apply the driving term</span>
    <span class="n">apply_driving</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

    <span class="c1">// update the boundaries</span>
    <span class="n">step_boundaries</span><span class="p">();</span>

    <span class="c1">// generate output if needed</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">%</span> <span class="n">out_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">save_output</span><span class="p">))</span> <span class="p">{</span>

      <span class="c1">// strncpy (fname, base_name, sizeof(fname));</span>
      <span class="n">s</span><span class="p">.</span><span class="n">str</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
      <span class="n">s</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
      <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">base_name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;_&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="o">/</span><span class="n">out_freq</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;.vtk&quot;</span><span class="p">;</span>
      <span class="n">fname</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
      <span class="n">write_output</span><span class="p">(</span><span class="n">fname</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="c1">// swap the storage vectors</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">cur_data</span><span class="p">,</span> <span class="n">old_data</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">cur_data</span><span class="p">,</span> <span class="n">new_data</span><span class="p">);</span>


  <span class="p">}</span>

<span class="p">};</span> <span class="c1">//end run</span>
</pre></div>
</div>
<p>}; // end wave_equation class</p>
</div>
</div>
</div>
<div class="section" id="main-routine">
<h3>Main Routine<a class="headerlink" href="#main-routine" title="Permalink to this headline">¶</a></h3>
<p>Finally, we will run a short simulation in each of the supported dimensions.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>

  <span class="kt">bool</span> <span class="n">write_output_files</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="c1">// read in input to see if we should write output files. If output files are</span>
  <span class="c1">// enabled this program writes out the 1D results 500 times which takes</span>
  <span class="c1">// approximately 7 MB of space. The 2D simulation generates 50 files, taking</span>
  <span class="c1">// up approximately 15 MB, and the 3D simulation generates 35 files taking up</span>
  <span class="c1">// about 120 MB.</span>
  <span class="c1">// By default, the file output is turned off.</span>
  <span class="c1">// There is only one option, so for simplicity we&#39;ll just assume that if we</span>
  <span class="c1">// receive any command line option, then we should enable output instead of</span>
  <span class="c1">// actually parsing and identifying a specific option.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;This program will generate output files.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">write_output_files</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;1D simulation ...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="c1">// first run the 1D wave equations</span>
  <span class="kt">int</span> <span class="n">npoints_1d</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1000</span><span class="p">};</span>
  <span class="kt">double</span> <span class="n">grid_spacing_1d</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.01</span><span class="p">};</span>
  <span class="kt">double</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ntsteps</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">bname</span> <span class="o">=</span> <span class="s">&quot;1d_wave&quot;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">out_freq</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">src_location_1d</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">350</span><span class="p">};</span>
  <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">Boundary</span> <span class="n">bounds_1d</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

  <span class="n">bounds_1d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">;</span>
  <span class="n">bounds_1d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">;</span>

  <span class="c1">// create a 1D simulation</span>
  <span class="n">wave_equation</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">wave1d</span><span class="p">(</span><span class="n">npoints_1d</span><span class="p">,</span>
                          <span class="n">grid_spacing_1d</span><span class="p">,</span>
                          <span class="n">c</span><span class="p">,</span>
                          <span class="n">bounds_1d</span><span class="p">,</span>
                          <span class="n">ntsteps</span><span class="p">,</span>
                          <span class="n">bname</span><span class="p">,</span>
                          <span class="n">out_freq</span><span class="p">,</span>
                          <span class="n">src_location_1d</span><span class="p">);</span>
  <span class="n">wave1d</span><span class="p">.</span><span class="n">set_write_output</span><span class="p">(</span><span class="n">write_output_files</span><span class="p">);</span>

  <span class="c1">// run</span>
  <span class="n">try</span> <span class="p">{</span>
    <span class="n">wave1d</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;something with wrong ...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span>  <span class="o">&lt;&lt;</span> <span class="s">&quot;2D simulation ...&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="c1">// now do a 2d simulation</span>
  <span class="kt">int</span> <span class="n">npoints_2d</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">200</span><span class="p">,</span> <span class="mi">200</span><span class="p">};</span>
  <span class="kt">double</span> <span class="n">grid_spacing_2d</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">};</span>
  <span class="n">ntsteps</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
  <span class="n">bname</span> <span class="o">=</span> <span class="s">&quot;2d_wave&quot;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">src_location_2d</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">75</span><span class="p">,</span> <span class="mi">120</span><span class="p">};</span>
  <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">Boundary</span> <span class="n">bounds_2d</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

  <span class="n">bounds_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">;</span>
  <span class="n">bounds_2d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">;</span>
  <span class="n">bounds_2d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">;</span>
  <span class="n">bounds_2d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">;</span>

  <span class="c1">// create a 2D simulation</span>
  <span class="n">wave_equation</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">wave2d</span><span class="p">(</span><span class="n">npoints_2d</span><span class="p">,</span>
                          <span class="n">grid_spacing_2d</span><span class="p">,</span>
                          <span class="n">c</span><span class="p">,</span>
                          <span class="n">bounds_2d</span><span class="p">,</span>
                          <span class="n">ntsteps</span><span class="p">,</span>
                          <span class="n">bname</span><span class="p">,</span>
                          <span class="n">out_freq</span><span class="p">,</span>
                          <span class="n">src_location_2d</span><span class="p">);</span>
  <span class="n">wave2d</span><span class="p">.</span><span class="n">set_write_output</span><span class="p">(</span><span class="n">write_output_files</span><span class="p">);</span>

  <span class="c1">// run</span>
  <span class="n">try</span> <span class="p">{</span>
    <span class="n">wave2d</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;something with wrong ...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;3D simulation ...&quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="c1">// now do a 3d simulation</span>
  <span class="kt">int</span> <span class="n">npoints_3d</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">75</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">75</span><span class="p">};</span>
  <span class="kt">double</span> <span class="n">grid_spacing_3d</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">};</span>
  <span class="n">ntsteps</span> <span class="o">=</span> <span class="mi">350</span><span class="p">;</span>
  <span class="n">bname</span> <span class="o">=</span> <span class="s">&quot;3d_wave&quot;</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">src_location_3d</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">};</span>
  <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">Boundary</span> <span class="n">bounds_3d</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

  <span class="n">bounds_3d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">;</span>
  <span class="n">bounds_3d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">;</span>
  <span class="n">bounds_3d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">;</span>
  <span class="n">bounds_3d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">;</span>
  <span class="n">bounds_3d</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">;</span>
  <span class="n">bounds_3d</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">crbc</span><span class="o">::</span><span class="n">BoundaryProperties</span><span class="o">::</span><span class="n">CRBC</span><span class="p">;</span>

  <span class="c1">// create a 3D simulation</span>
  <span class="n">wave_equation</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">wave3d</span><span class="p">(</span><span class="n">npoints_3d</span><span class="p">,</span>
                          <span class="n">grid_spacing_3d</span><span class="p">,</span>
                          <span class="n">c</span><span class="p">,</span>
                          <span class="n">bounds_3d</span><span class="p">,</span>
                          <span class="n">ntsteps</span><span class="p">,</span>
                          <span class="n">bname</span><span class="p">,</span>
                          <span class="n">out_freq</span><span class="p">,</span>
                          <span class="n">src_location_3d</span><span class="p">);</span>
  <span class="n">wave3d</span><span class="p">.</span><span class="n">set_write_output</span><span class="p">(</span><span class="n">write_output_files</span><span class="p">);</span>

  <span class="c1">// run</span>
  <span class="n">try</span> <span class="p">{</span>
    <span class="n">wave3d</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
  <span class="p">}</span> <span class="n">catch</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;something with wrong ...&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="output">
<h2>Output<a class="headerlink" href="#output" title="Permalink to this headline">¶</a></h2>
<p>Some simple videos showing the results can be seen for the 1D results</p>
<div style="text-align: center">
  <iframe width="600" height="450" src="https://www.youtube.com/embed/X7WMaiKH1WQ" frameborder="0" allowfullscreen></iframe>
</div><p>and for the 2D results</p>
<div style="text-align: center">
  <iframe width="600" height="450" src="https://www.youtube.com/embed/mYW1s63RzLc" frameborder="0" allowfullscreen></iframe>
</div><p>The files used to generate these movies can be generated by providing a command line
option at runtime, for instance</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">wave_eq</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span><span class="n">output</span>
</pre></div>
</div>
<p>The following screen output is generated</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="n">D</span> <span class="n">simulation</span> <span class="p">...</span>

<span class="n">Recursion</span> <span class="n">properties</span> <span class="n">by</span> <span class="n">face</span> <span class="p">(</span><span class="n">reflection</span> <span class="n">coef</span> <span class="o">=-</span><span class="mi">1</span> <span class="n">means</span> <span class="n">that</span> <span class="n">no</span> <span class="n">updates</span> <span class="n">are</span> <span class="n">performed</span><span class="p">)</span>
  <span class="n">Left</span> <span class="n">side</span> <span class="n">in</span> <span class="nl">x</span><span class="p">:</span>
    <span class="n">recursions</span>      <span class="o">=</span> <span class="mi">0</span>
    <span class="n">reflection</span> <span class="n">coef</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
  <span class="n">Right</span> <span class="n">side</span> <span class="n">in</span> <span class="nl">x</span><span class="p">:</span>
    <span class="n">recursions</span>      <span class="o">=</span> <span class="mi">0</span>
    <span class="n">reflection</span> <span class="n">coef</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">The</span> <span class="n">maximum</span> <span class="n">reflection</span> <span class="n">coeficient</span> <span class="n">is</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">The</span> <span class="n">CRBC</span> <span class="n">library</span> <span class="n">is</span> <span class="n">updating</span>
  <span class="mi">2</span> <span class="n">faces</span>
  <span class="mi">0</span> <span class="n">edges</span>
  <span class="mi">0</span> <span class="n">corners</span>


<span class="mi">2</span><span class="n">D</span> <span class="n">simulation</span> <span class="p">...</span>

<span class="n">Recursion</span> <span class="n">properties</span> <span class="n">by</span> <span class="n">face</span> <span class="p">(</span><span class="n">reflection</span> <span class="n">coef</span> <span class="o">=-</span><span class="mi">1</span> <span class="n">means</span> <span class="n">that</span> <span class="n">no</span> <span class="n">updates</span> <span class="n">are</span> <span class="n">performed</span><span class="p">)</span>
  <span class="n">Left</span> <span class="n">side</span> <span class="n">in</span> <span class="nl">x</span><span class="p">:</span>
    <span class="n">recursions</span>      <span class="o">=</span> <span class="mi">5</span>
    <span class="n">reflection</span> <span class="n">coef</span> <span class="o">=</span> <span class="mf">1.83167e-05</span>
  <span class="n">Right</span> <span class="n">side</span> <span class="n">in</span> <span class="nl">x</span><span class="p">:</span>
    <span class="n">recursions</span>      <span class="o">=</span> <span class="mi">5</span>
    <span class="n">reflection</span> <span class="n">coef</span> <span class="o">=</span> <span class="mf">1.83167e-05</span>
  <span class="n">Left</span> <span class="n">side</span> <span class="n">in</span> <span class="nl">y</span><span class="p">:</span>
    <span class="n">recursions</span>      <span class="o">=</span> <span class="mi">5</span>
    <span class="n">reflection</span> <span class="n">coef</span> <span class="o">=</span> <span class="mf">1.83167e-05</span>
  <span class="n">Right</span> <span class="n">side</span> <span class="n">in</span> <span class="nl">y</span><span class="p">:</span>
    <span class="n">recursions</span>      <span class="o">=</span> <span class="mi">5</span>
    <span class="n">reflection</span> <span class="n">coef</span> <span class="o">=</span> <span class="mf">1.83167e-05</span>
<span class="n">The</span> <span class="n">maximum</span> <span class="n">reflection</span> <span class="n">coeficient</span> <span class="n">is</span> <span class="mf">1.83167e-05</span>
<span class="n">The</span> <span class="n">CRBC</span> <span class="n">library</span> <span class="n">is</span> <span class="n">updating</span>
  <span class="mi">4</span> <span class="n">faces</span>
  <span class="mi">4</span> <span class="n">edges</span>
  <span class="mi">0</span> <span class="n">corners</span>


<span class="mi">3</span><span class="n">D</span> <span class="n">simulation</span> <span class="p">...</span>

<span class="n">Recursion</span> <span class="n">properties</span> <span class="n">by</span> <span class="n">face</span> <span class="p">(</span><span class="n">reflection</span> <span class="n">coef</span> <span class="o">=-</span><span class="mi">1</span> <span class="n">means</span> <span class="n">that</span> <span class="n">no</span> <span class="n">updates</span> <span class="n">are</span> <span class="n">performed</span><span class="p">)</span>
  <span class="n">Left</span> <span class="n">side</span> <span class="n">in</span> <span class="nl">x</span><span class="p">:</span>
    <span class="n">recursions</span>      <span class="o">=</span> <span class="mi">2</span>
    <span class="n">reflection</span> <span class="n">coef</span> <span class="o">=</span> <span class="mf">0.00450971</span>
  <span class="n">Right</span> <span class="n">side</span> <span class="n">in</span> <span class="nl">x</span><span class="p">:</span>
    <span class="n">recursions</span>      <span class="o">=</span> <span class="mi">2</span>
    <span class="n">reflection</span> <span class="n">coef</span> <span class="o">=</span> <span class="mf">0.00450971</span>
  <span class="n">Left</span> <span class="n">side</span> <span class="n">in</span> <span class="nl">y</span><span class="p">:</span>
    <span class="n">recursions</span>      <span class="o">=</span> <span class="mi">2</span>
    <span class="n">reflection</span> <span class="n">coef</span> <span class="o">=</span> <span class="mf">0.00450971</span>
  <span class="n">Right</span> <span class="n">side</span> <span class="n">in</span> <span class="nl">y</span><span class="p">:</span>
    <span class="n">recursions</span>      <span class="o">=</span> <span class="mi">2</span>
    <span class="n">reflection</span> <span class="n">coef</span> <span class="o">=</span> <span class="mf">0.00629783</span>
  <span class="n">Left</span> <span class="n">side</span> <span class="n">in</span> <span class="nl">z</span><span class="p">:</span>
    <span class="n">recursions</span>      <span class="o">=</span> <span class="mi">2</span>
    <span class="n">reflection</span> <span class="n">coef</span> <span class="o">=</span> <span class="mf">0.00450971</span>
  <span class="n">Right</span> <span class="n">side</span> <span class="n">in</span> <span class="nl">z</span><span class="p">:</span>
    <span class="n">recursions</span>      <span class="o">=</span> <span class="mi">2</span>
    <span class="n">reflection</span> <span class="n">coef</span> <span class="o">=</span> <span class="mf">0.00450971</span>
<span class="n">The</span> <span class="n">maximum</span> <span class="n">reflection</span> <span class="n">coeficient</span> <span class="n">is</span> <span class="mf">0.00629783</span>
<span class="n">The</span> <span class="n">CRBC</span> <span class="n">library</span> <span class="n">is</span> <span class="n">updating</span>
  <span class="mi">6</span> <span class="n">faces</span>
  <span class="mi">12</span> <span class="n">edges</span>
  <span class="mi">8</span> <span class="n">corners</span>
</pre></div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/YeeCRBC/wave_eq_example_in_Cpp.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
    <a href="../contrib.html">rbcpack Contributors </a><br />
        &copy; Copyright 2015-2016, rbcpack.org.<br/>
    </p>
  </div>
</footer>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71984541-1', 'auto');
  ga('send', 'pageview');

</script>


  </body>
</html>